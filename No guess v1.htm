<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minesweeper</title>
    <!-- Firebase App (include only once) -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4;
            --flagged-cell-color: #FFD700;
            --mine-bg-color: #B22222;
            --mine-revealed-bg: #800000;
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D;
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */
        }

        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB;
            --flagged-cell-color: #B22222;
            --mine-bg-color: #F08080;
            --mine-revealed-bg: #DC143C;
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700;
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell b*/
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }
         #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--container-bg);
            padding: 10px;
        }

        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
             user-select: none;
             -webkit-tap-highlight-color: transparent;
             /* touch-action: manipulation; might also be helpful here */
        }

        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        .cell.mine {
            background-color: var(--mine-bg-color);
        }
        .cell.mine-revealed {
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }
        /* Cell colors based on number */
        .cell[data-adjacent-mines="1"] { color: blue; }
        .cell[data-adjacent-mines="2"] { color: green; }
        .cell[data-adjacent-mines="3"] { color: red; }
        .cell[data-adjacent-mines="4"] { color: navy; }
        .cell[data-adjacent-mines="5"] { color: brown; }
        .cell[data-adjacent-mines="6"] { color: teal; }
        .cell[data-adjacent-mines="7"] { color: black; }
        .cell[data-adjacent-mines="8"] { color: gray; }

        .light-mode .cell[data-adjacent-mines="1"] { color: #0000FF; }
        .light-mode .cell[data-adjacent-mines="2"] { color: #008000; }
        .light-mode .cell[data-adjacent-mines="3"] { color: #FF0000; }
        .light-mode .cell[data-adjacent-mines="4"] { color: #000080; }
        .light-mode .cell[data-adjacent-mines="5"] { color: #800000; }
        .light-mode .cell[data-adjacent-mines="6"] { color: #008080; }
        .light-mode .cell[data-adjacent-mines="7"] { color: #000000; }
        .light-mode .cell[data-adjacent-mines="8"] { color: #808080; }


        #controls {
            display: flex;
            justify-content: space-around;
            width: 90%;
            margin-bottom: 10px;
            align-items: center;
        }

        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }

        #settings {
            margin-top: 20px;
        }

        #settings button {
            padding: 10px 20px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings button:hover {
            background-color: var(--button-hover-bg);
        }

          #settings-panel {
            display: none;
            position: fixed;
            top: 50%; /* Start at 50% */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            width: 90%;
            max-width: 450px;
            border-radius: 12px;
            overflow-y: auto;  /* Enable vertical scrolling */
            max-height: 80vh; /* Limit height to 80% of viewport height */

        }
        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }

        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"] { /* Apply styles to text input too */
            width: 70px;
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 5px;
            font-size: 1em;
        }
         #settings-panel input[type="text"]{
             width: calc(100% - 20px); /* Take full width minus padding */
         }

        #settings-panel input[type="range"] {
            width: 100%;
        }

        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings-panel button:hover {
            background-color: var(--button-hover-bg);;
        }

        #settings-panel .setting-group {
           margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
          #settings-panel .difficulty-buttons {
            display: flex;
            justify-content: space-between; /* Evenly space buttons */
            margin-bottom: 15px;
        }
          #settings-panel .difficulty-buttons button {
            flex: 1; /* Each button takes equal width */
            margin: 0 5px; /* Space between buttons */
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 999;
        }

        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }

        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;

        }

        /* Toggle switch styles */
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
          margin-bottom: 12px;
          vertical-align: middle; /* Align switch vertically with label */
        }
         /* Align label text vertically with switch */
        #settings-panel .switch-label {
             display: inline-block;
             vertical-align: middle;
             margin-right: 10px;
             margin-bottom: 12px; /* Match switch margin */
        }


        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 34px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(26px);
          -ms-transform: translateX(26px);
          transform: translateX(26px);
        }
        #settings-panel select{
            margin-bottom: 10px;
            padding: 5px;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            margin: 0 auto;
            border-collapse: collapse;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
        }
        .custom-settings {
            display: none; /* Initially hidden */
        }

        .custom-settings.active {
            display: block; /* Show when active */
        }
         #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            margin: 0 auto;
            border-collapse: collapse;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
       }
      #leaderboard-loading {
          margin-bottom: 10px;
      }
       /* Style for online leaderboard tables */
      #online-leaderboard-container {
        display: flex; /* Use flexbox for side-by-side tables */
        justify-content: space-around; /* Distribute space evenly */
        flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
        width: 90%;
        margin: 20px auto;

      }

      #online-leaderboard-container table {
        width: 45%; /* Each table takes roughly half the container width */
        margin-bottom: 20px; /* Space between tables */
        border-collapse: collapse;
         box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
        #online-leaderboard-container th,
        #online-leaderboard-container td {
             padding: 8px;
              border: 1px solid var(--control-border-color);
              text-align: center;
        }
        #online-leaderboard-container th {
             background-color: var(--control-bg-color);
              color: var(--text-color);
               font-weight: bold;
        }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        #online-leaderboard-container {
          flex-direction: column; /* Stack tables vertically on smaller screens */
        }
          #online-leaderboard-container table {
            width: 90%; /* Tables take full width on smaller screens */
             margin: 10px auto;
          }
      }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls">
            <div id="mines-left">
                <div id="mines-left-label">Mines</div>
                <div></div>
            </div>
            <div id="timer">
                 <div id="timer-label">Timer</div>
                <div>0</div>
            </div>
        </div>
        <div id="grid-container"></div>
    </div>
    <div id="settings">
        <button onclick="toggleSettings()">Settings</button>
    </div>

      <div id="settings-panel">
        <h2>Settings</h2>
        <div class="setting-group difficulty-buttons">
            <button onclick="setDifficulty('beginner')">Beginner</button>
            <button onclick="setDifficulty('intermediate')">Intermediate</button>
            <button onclick="setDifficulty('expert')">Expert</button>
            <button onclick="setDifficulty('custom')">Custom</button> <!-- Custom Difficulty Button -->
        </div>
        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>

        <div class="custom-settings setting-group">
            <label for="width">Width:</label>
            <input type="number" id="width" min="5" max="30" value="9">
            <label for="height">Height:</label>
            <input type="number" id="height" min="5" max="30" value="9">
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="99" value="10">
        </div>

        <div class="setting-group"> <!-- Gameplay Options Group -->
            <label for="no-guess-mode" class="switch-label">No Guess Mode:</label>
            <label class="switch">
                <input type="checkbox" id="no-guess-mode">
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-group">
            <label for="light-mode" class="switch-label">Light Mode:</label>
            <label class="switch">
                <input type="checkbox" id="light-mode">
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method" onchange="updateFlagMethod()">
              <option value="longPress">Long Press</option>
              <option value="doubleTap">Double Tap</option>
              <option value="rightClick">Right Click</option>
            </select>
        </div>

        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>

        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        <button onclick="applySettings()">Apply</button>
        <button onclick="toggleSettings()">Close</button>
    </div>

    <div id="overlay"></div>
     <div id="message-box">
      <p id="message-text"></p>
      <button onclick="restartGame()">Restart</button>
    </div>
      <div id="online-leaderboard-container">
        <div id="leaderboard-loading">Loading leaderboards...</div>
        <div id="leaderboard-error" style="color: red; display: none;">Error loading leaderboards.</div>

        <table>
            <thead><tr><th colspan="3">Beginner</th></tr></thead>
            <tbody id="leaderboard-beginner"></tbody>
        </table>

        <table>
             <thead><tr><th colspan="3">Intermediate</th></tr></thead>
            <tbody id="leaderboard-intermediate"></tbody>
        </table>

        <table>
            <thead><tr><th colspan="3">Expert</th></tr></thead>
            <tbody id="leaderboard-expert"></tbody>
        </table>
      </div>

      <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best Time</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Beginner</td>
                    <td id="leaderboard-beginner-local">-</td>
                </tr>
                <tr>
                    <td>Intermediate</td>
                    <td id="leaderboard-intermediate-local">-</td>
                </tr>
                <tr>
                    <td>Expert</td>
                    <td id="leaderboard-expert-local">-</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
     // Firebase configuration
    const firebaseConfig = {
      // --- REMOVED FOR SAFETY - Replace with your actual config ---
       apiKey: "YOUR_API_KEY",
       authDomain: "YOUR_AUTH_DOMAIN",
       projectId: "YOUR_PROJECT_ID",
       storageBucket: "YOUR_STORAGE_BUCKET",
       messagingSenderId: "YOUR_SENDER_ID",
       appId: "YOUR_APP_ID",
       measurementId: "YOUR_MEASUREMENT_ID"
      // --- END REMOVED SECTION ---
    };

    // Initialize Firebase
    let db;
    try {
        if (!firebase.apps.length) {
            const firebaseApp = firebase.initializeApp(firebaseConfig);
            db = firebaseApp.firestore();
        } else {
            db = firebase.app().firestore();
        }
    } catch (e) {
        console.error("Firebase initialization failed:", e);
        db = null; // Indicate failure
        // Optionally disable Firebase features or show a message
        document.getElementById('leaderboard-loading').textContent = 'Online leaderboards disabled.';
        document.getElementById('leaderboard-error').textContent = 'Could not connect to online services.';
        document.getElementById('leaderboard-error').style.display = 'block';

    }


    let grid = [];
    let width = 9;
    let height = 9;
    let numMines = 10;
    let minesLeft = numMines;
    let timerInterval;
    let time = 0;
    let gameStarted = false;
    let gameOver = false;
    let firstClick = true;
    let touchLongPressTimerId = null;
    let mouseLongPressTimerId = null;
    let ignoreNextClick = false; // Specifically for preventing click after touch long press
    let longPressFlaggedThisTouch = false; // Flag set when touch long press timer completes
    let longPressJustFinishedMouse = false; // Flag for mouse long press completion
    let isLeftMouseDown = false;
    let pressedCellElement = null;
    let initialMouseDownCell = null;
    let longPressDelay = 500;
    let flagMethod = "longPress";
    let chordMethod = "singleTap";
    let doubleTapChordTimer = null;
    let doubleTapFlagTimer = null;
    let currentDifficulty = "beginner";
    let playerName = "Player";
    let noGuessMode = false; // --- New state variable ---

    // --- Helper function for generating random integers ---
    function randomInt(max) { // max is exclusive
        return Math.floor(Math.random() * max);
    }

    // --- Helper function to shuffle an array (Fisher-Yates) ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = randomInt(i + 1);
            [array[i], array[j]] = [array[j], array[i]];
        }
    }


    function createGrid() {
      const gridContainer = document.getElementById('grid-container');
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
      grid = [];

      for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleClick); // Keep click for touch taps
          cell.addEventListener('mousedown', handleCellMouseDown);
          cell.addEventListener('contextmenu', handleRightClick);
          cell.addEventListener('mouseover', handleCellMouseOver);
          cell.addEventListener('mouseout', handleCellMouseOut);

          // Apply touch/long press listeners based on settings
          updateFlagMethod(cell, x, y);

          gridContainer.appendChild(cell);
          grid[y][x] = {
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            adjacentMines: 0,
            element: cell,
          };
        }
      }
      updateMinesLeftDisplay();
      updateTimerDisplay();
      gridContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); });
      document.addEventListener('mouseup', handleDocumentMouseUp);
    }

    function handleRightClick(event) {
      event.preventDefault();
    }

    function handleCellMouseDown(event) {
        if (gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        initialMouseDownCell = targetCell;

        if (event.button === 2) { // Right click
            event.preventDefault();
             // Only allow right-click flagging if enabled or long press is also enabled
             if (flagMethod === 'rightClick' || flagMethod === 'longPress') {
                handleFlag(event);
             }
            return;
        }


        if (event.button === 0) { // Left click
             if (flagMethod === 'longPress') {
                 clearTimeout(mouseLongPressTimerId);
                 longPressJustFinishedMouse = false; // Reset mouse long press flag
                 mouseLongPressTimerId = setTimeout(() => {
                     handleFlag(event);
                     longPressJustFinishedMouse = true; // Set flag specific to mouse
                     mouseLongPressTimerId = null;
                     if (pressedCellElement) {
                        pressedCellElement.classList.remove('pressed');
                     }
                     pressedCellElement = null;
                 }, longPressDelay);
             }

             isLeftMouseDown = true;
             pressedCellElement = targetCell;
             const cellData = getCellData(targetCell);
             if (cellData && !cellData.isRevealed) {
                pressedCellElement.classList.add('pressed');
             }
        }
    }

    function handleCellMouseOver(event) {
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        const cellData = getCellData(targetCell);
        if (!cellData || cellData.isRevealed) {
             if (pressedCellElement && pressedCellElement !== targetCell) {
                 pressedCellElement.classList.remove('pressed');
             }
             pressedCellElement = null;
             return;
        }

        if (targetCell !== pressedCellElement) {
            if (pressedCellElement) {
                pressedCellElement.classList.remove('pressed');
            }
            targetCell.classList.add('pressed');
            pressedCellElement = targetCell;
        }
    }

    function handleCellMouseOut(event) {
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (targetCell === pressedCellElement) {
             pressedCellElement.classList.remove('pressed');
             pressedCellElement = null;
        }
    }


    function handleDocumentMouseUp(event) {
        if (event.button !== 0 || !isLeftMouseDown) {
            if (pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
                 pressedCellElement = null;
            }
            isLeftMouseDown = false;
            clearTimeout(mouseLongPressTimerId); // Clear MOUSE long press timer
            mouseLongPressTimerId = null;
            initialMouseDownCell = null;
            return;
        }

        isLeftMouseDown = false;
        const mouseUpTargetElement = document.elementFromPoint(event.clientX, event.clientY);
        const mouseUpCellElement = mouseUpTargetElement ? mouseUpTargetElement.closest('.cell') : null;

        clearTimeout(mouseLongPressTimerId); // Clear any running MOUSE long press timer
        mouseLongPressTimerId = null;

        if (pressedCellElement) {
            pressedCellElement.classList.remove('pressed');
        }
        pressedCellElement = null;


        if (longPressJustFinishedMouse) { // Check MOUSE long press flag
            longPressJustFinishedMouse = false; // Reset mouse flag
            initialMouseDownCell = null; // Reset initial cell after long press flag
            return; // Do not reveal/chord if mouse long press just flagged
        }

         // --- Added check: only proceed if mouse up is on the *same cell* as mouse down ---
         if (!mouseUpCellElement || mouseUpCellElement !== initialMouseDownCell) {
             initialMouseDownCell = null; // Reset even if mouse up is elsewhere
             return;
         }
         // --- End added check ---

         initialMouseDownCell = null; // Reset initial cell after successful action

        if (gameOver) return;

        if (mouseUpCellElement) {
            const x = parseInt(mouseUpCellElement.dataset.x);
            const y = parseInt(mouseUpCellElement.dataset.y);

             if (firstClick) {
                 handleFirstClick(x, y); // Use dedicated function
             }

             const cellData = grid[y][x];

             if (cellData && !cellData.isFlagged) { // Cannot reveal/chord flagged cells
                if (cellData.isRevealed) {
                     chord(x, y);
                } else {
                    revealCell(x, y);
                }
             }
        }
    }


    function updateFlagMethod(cell, x, y) {
        if(!cell){ // If called without a specific cell, update all
            for(let r = 0; r < height; r++){
                for(let c = 0; c < width; c++){
                    if (grid[r] && grid[r][c] && grid[r][c].element) {
                       updateFlagMethod(grid[r][c].element, c, r);
                    }
                }
            }
            return;
        }

        // Remove potentially conflicting listeners first
        cell.removeEventListener('touchstart', handleDoubleTapFlag);
        removeLongPressListener(cell); // Removes TOUCH listeners and MOUSELEAVE added by addLongPressListener

        if (flagMethod === 'longPress') {
            addLongPressListener(cell, handleFlag); // Adds TOUCH listeners + mouseleave cleanup
        } else if (flagMethod === 'doubleTap') {
            cell.addEventListener('touchstart', handleDoubleTapFlag);
        } else if (flagMethod === 'rightClick') {
            // Right click flagging is primarily handled in handleCellMouseDown
            // No specific event listener needs to be added *here* for right-click only
        }
    }

    function handleDoubleTapFlag(event){
        event.preventDefault(); // Prevent potential zoom or other default actions
        if(gameOver || flagMethod !== 'doubleTap') return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
         const cellData = getCellData(targetCell);
         if(!cellData || cellData.isRevealed) return; // Cannot flag revealed cells

        if(doubleTapFlagTimer === null){
            doubleTapFlagTimer = setTimeout(() => {
                doubleTapFlagTimer = null;
                // Treat as a single tap (reveal) if timer expires
                 if (firstClick) {
                    handleFirstClick(cellData.x, cellData.y);
                 }
                 if (!cellData.isFlagged) { // Don't reveal if it got flagged somehow
                     revealCell(cellData.x, cellData.y);
                 }

            }, 300); // Standard double-tap timeout
        }
        else{
            // Double tap detected
            clearTimeout(doubleTapFlagTimer);
            doubleTapFlagTimer = null;
            handleFlag(event); // Execute the flag action
        }
    }
    function handleDoubleTapChord(event){
         event.preventDefault();
        if(gameOver || chordMethod !== 'doubleTap') return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const cellData = getCellData(targetCell);
         if(!cellData || !cellData.isRevealed) return; // Can only chord revealed cells


         if (doubleTapChordTimer === null) {
            doubleTapChordTimer = setTimeout(() => {
                doubleTapChordTimer = null;
                 // If timer expires, do nothing (single tap on revealed does nothing extra)
            }, 300);
        } else {
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
            chord(cellData.x, cellData.y); // Execute chord action
        }
    }

    // --- Function to get cell data safely ---
    function getCellData(element) {
        if (!element) return null;
        const x = parseInt(element.dataset.x);
        const y = parseInt(element.dataset.y);
        if (isNaN(x) || isNaN(y) || !grid[y] || !grid[y][x]) {
            // console.warn("Could not get cell data for element:", element);
            return null;
        }
        return grid[y][x];
    }


    // --- Mine Placement Logic ---
    function placeMines(safeX, safeY) {
        // Use standard random placement if not in No Guess Mode
        if (!noGuessMode) {
            placeMinesRandomly(safeX, safeY);
        } else {
            // Use the guaranteed solvable generation logic
            if (!generateNoGuessGrid(safeX, safeY)) {
                // Fallback or error handling if generation fails
                console.error("No Guess grid generation failed! Falling back to random.");
                alert("Failed to generate a no-guess grid. Using standard random layout.");
                placeMinesRandomly(safeX, safeY);
                noGuessMode = false; // Turn off the mode if generation failed
                // Update the checkbox in settings if it's open
                const ngCheckbox = document.getElementById('no-guess-mode');
                if(ngCheckbox) ngCheckbox.checked = false;
                 localStorage.setItem('noGuessMode', 'disabled');
            }
             // Ensure adjacent mines are calculated AFTER generation
             calculateAdjacentMines();
        }
         // Always calculate adjacent mines after placement
         calculateAdjacentMines();
    }

    function placeMinesRandomly(safeX, safeY) {
        let minesToPlace = numMines;
        const startTime = Date.now();
        const timeout = 5000; // 5 seconds timeout

        while (minesToPlace > 0) {
            if (Date.now() - startTime > timeout) {
                console.error("Timeout placing mines randomly.");
                alert("Error placing mines (timeout). Please try reducing mines or grid size.");
                // Reset grid to avoid partial state
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        grid[y][x].isMine = false;
                    }
                }
                 // Mark first click as safe just in case
                 if (grid[safeY] && grid[safeY][safeX]) grid[safeY][safeX].isMine = false;
                return false; // Indicate failure
            }

            const x = randomInt(width);
            const y = randomInt(height);

            if (!grid[y][x].isMine && !isNearSafeZone(x, y, safeX, safeY)) {
                grid[y][x].isMine = true;
                minesToPlace--;
            }
        }
         // Ensure the safe zone itself is clear (belt-and-braces)
         for(let dx = -1; dx <= 1; dx++){
             for(let dy = -1; dy <= 1; dy++){
                 const nx = safeX + dx;
                 const ny = safeY + dy;
                 if(isValid(nx, ny) && grid[ny][nx]) {
                    grid[ny][nx].isMine = false;
                 }
             }
         }
         return true; // Indicate success
    }

    // --- No Guess Mode Generation ---
    function generateNoGuessGrid(safeX, safeY) {
        console.log("Generating No-Guess Grid...");
        const maxAttempts = 100; // Limit attempts to prevent infinite loops
        let attempts = 0;
        let generationSuccess = false;

        // 1. Initial Random Placement (respecting safe zone)
        if (!placeMinesRandomly(safeX, safeY)) {
            console.error("Initial random placement failed for No Guess mode.");
            return false; // Cannot proceed if initial placement fails
        }
        calculateAdjacentMines(); // Calculate numbers based on initial placement

        // 2. Iterative Solving and Perturbation
        while (attempts < maxAttempts) {
            attempts++;
            // console.log(`No Guess Attempt: ${attempts}`);
            const solverResult = solveGridLogically(safeX, safeY);

            if (solverResult.success) {
                // console.log("No Guess Grid generated successfully!");
                generationSuccess = true;
                break; // Grid is solvable
            } else if (solverResult.stuck) {
                // console.log("Solver stuck, perturbing grid...");
                if (!perturbGrid(solverResult.stuckState, safeX, safeY)) {
                    console.warn("Perturbation failed. Trying again with current layout.");
                    // Optional: Could try a different perturbation or just loop again
                }
                 // Recalculate adjacent mines after perturbation
                 calculateAdjacentMines();
            } else {
                // Solver failed unexpectedly (e.g., internal error)
                console.error("Solver encountered an error.");
                break;
            }
        }

        if (!generationSuccess) {
            console.error(`No Guess generation failed after ${attempts} attempts.`);
            return false;
        }

        // 3. Final Check (Optional but recommended)
        // Run the solver one last time to ensure the final grid is truly solvable
        const finalCheck = solveGridLogically(safeX, safeY);
        if (!finalCheck.success) {
             console.error("Final check failed! The generated No Guess grid is not solvable.");
             // This indicates a bug in the solver or perturbation logic
             return false;
        }

        console.log("No Guess Grid Generation Complete.");
        return true;
    }

    // --- Basic Logical Solver (Placeholder/Simplified) ---
    // This needs to be significantly expanded based on the C code's logic
    function solveGridLogically(startX, startY) {
        // Create a copy of the grid state representing player knowledge
        let knownGrid = [];
        let revealedCount = 0;
        let flaggedCount = 0; // Track flags for global deduction later
        const totalNonMines = width * height - numMines;

        for (let y = 0; y < height; y++) {
            knownGrid[y] = [];
            for (let x = 0; x < width; x++) {
                // -2: Unknown, -1: Flagged, 0-8: Revealed Number
                knownGrid[y][x] = -2;
            }
        }

        // Start by revealing the initial safe square (and its neighbors if it's a 0)
        let revealQueue = [{ x: startX, y: startY }];
        knownGrid[startY][startX] = grid[startY][startX].adjacentMines;
        revealedCount++;

        let iterations = 0;
        const maxIterations = width * height * 5; // Safety break

        while (iterations < maxIterations) {
            iterations++;
            let changed = false;

            // Process reveal queue first (flood fill 0s)
            while(revealQueue.length > 0) {
                const {x, y} = revealQueue.shift();
                if (knownGrid[y][x] === 0) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (isValid(nx, ny) && knownGrid[ny][nx] === -2) { // If unknown
                                knownGrid[ny][nx] = grid[ny][nx].adjacentMines;
                                revealedCount++;
                                changed = true;
                                if (knownGrid[ny][nx] === 0) {
                                    revealQueue.push({ x: nx, y: ny });
                                }
                            }
                        }
                    }
                }
            }


            // Basic Logic 1: If known mines == number, reveal neighbors
            // Basic Logic 2: If unknown neighbors == number - known mines, flag neighbors
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (knownGrid[y][x] > 0 && knownGrid[y][x] <= 8) { // If it's a revealed number > 0
                        let unknownNeighbors = [];
                        let flaggedNeighborsCount = 0;
                        const number = knownGrid[y][x];

                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValid(nx, ny)) {
                                    if (knownGrid[ny][nx] === -1) {
                                        flaggedNeighborsCount++;
                                    } else if (knownGrid[ny][nx] === -2) {
                                        unknownNeighbors.push({ x: nx, y: ny });
                                    }
                                }
                            }
                        }

                        // Logic 1: Reveal safe neighbors
                        if (flaggedNeighborsCount === number && unknownNeighbors.length > 0) {
                            unknownNeighbors.forEach(n => {
                                if (knownGrid[n.y][n.x] === -2) { // Double check it's still unknown
                                     knownGrid[n.y][n.x] = grid[n.y][n.x].adjacentMines;
                                     revealedCount++;
                                     changed = true;
                                     if(knownGrid[n.y][n.x] === 0) {
                                        revealQueue.push({x: n.x, y: n.y});
                                     }
                                }
                            });
                            unknownNeighbors = []; // Clear since they are revealed now
                        }

                        // Logic 2: Flag determined mines
                        if (unknownNeighbors.length > 0 && unknownNeighbors.length === number - flaggedNeighborsCount) {
                            unknownNeighbors.forEach(n => {
                                if (knownGrid[n.y][n.x] === -2) { // Double check it's still unknown
                                     knownGrid[n.y][n.x] = -1; // Flag it
                                     flaggedCount++;
                                     changed = true;
                                }
                            });
                             unknownNeighbors = []; // Clear since they are flagged now
                        }
                    }
                }
            }

            // Check for completion
            if (revealedCount === totalNonMines) {
                return { success: true, stuck: false };
            }

            // If no changes were made in this iteration, the solver is stuck
            if (!changed && revealQueue.length === 0) {
                 // Advanced Logic Placeholder: Add subset/superset analysis and global count logic here later
                 // For now, just return stuck
                 // console.log("Solver stuck at iteration", iterations, "Revealed:", revealedCount, "Flags:", flaggedCount);
                 return { success: false, stuck: true, stuckState: knownGrid };
            }
        }

        console.error("Solver exceeded max iterations.");
        return { success: false, stuck: false }; // Indicate failure due to iteration limit
    }

     // --- Perturbation Function (Simplified) ---
     function perturbGrid(knownGrid, safeX, safeY) {
         let unknownSquares = [];
         let mineSquares = [];
         let nonMineSquaresOutsideSafe = [];

         // Identify unknown squares (candidates for needing change) and all mine locations
         for (let y = 0; y < height; y++) {
             for (let x = 0; x < width; x++) {
                 if (knownGrid[y][x] === -2) {
                     unknownSquares.push({ x, y });
                 }
                 if (grid[y][x].isMine) {
                     mineSquares.push({ x, y });
                 } else if (!isNearSafeZone(x,y, safeX, safeY)) { // Collect non-mines for potential swaps
                     nonMineSquaresOutsideSafe.push({ x, y });
                 }
             }
         }

         if (unknownSquares.length === 0 || mineSquares.length === 0 || nonMineSquaresOutsideSafe.length === 0) {
             console.warn("Perturbation failed: No suitable squares found.");
             return false; // Cannot perturb if no unknowns or no mines/non-mines to swap
         }

         shuffleArray(unknownSquares);
         shuffleArray(mineSquares);
         shuffleArray(nonMineSquaresOutsideSafe);

         // Try to swap an unknown mine with a known/unknown non-mine outside the safe zone
         for (const unknownSq of unknownSquares) {
             if (grid[unknownSq.y][unknownSq.x].isMine) { // Found an unknown mine
                 for (const nonMineSq of nonMineSquaresOutsideSafe) {
                    // Check if the non-mine is NOT unknown (already revealed) OR truly unknown
                    if (knownGrid[nonMineSq.y][nonMineSq.x] !== -1 ) { // Make sure it's not flagged
                         // Perform the swap
                         // console.log(`Perturb: Swapping Mine at (${unknownSq.x},${unknownSq.y}) with Empty at (${nonMineSq.x},${nonMineSq.y})`);
                         grid[unknownSq.y][unknownSq.x].isMine = false;
                         grid[nonMineSq.y][nonMineSq.x].isMine = true;
                         return true; // Perturbation successful
                     }
                 }
             }
         }


         // Fallback: Try swapping an unknown non-mine with a known/unknown mine outside the safe zone
         for (const unknownSq of unknownSquares) {
             if (!grid[unknownSq.y][unknownSq.x].isMine) { // Found an unknown non-mine
                 for (const mineSq of mineSquares) {
                     if (!isNearSafeZone(mineSq.x, mineSq.y, safeX, safeY)) { // Ensure mine is outside safe zone
                         // Perform the swap
                           // console.log(`Perturb: Swapping Empty at (${unknownSq.x},${unknownSq.y}) with Mine at (${mineSq.x},${mineSq.y})`);
                         grid[unknownSq.y][unknownSq.x].isMine = true;
                         grid[mineSq.y][mineSq.x].isMine = false;
                         return true; // Perturbation successful
                     }
                 }
             }
         }


         console.warn("Perturbation failed: Could not find a suitable swap.");
         return false; // No suitable swap found
     }


    // --- End No Guess Mode Generation ---


    function isNearSafeZone(x, y, safeX, safeY){
        for(let dx = -1; dx <= 1; dx++){
            for(let dy = -1; dy <= 1; dy++){
                if(x + dx === safeX && y + dy === safeY){
                    return true;
                }
            }
        }
        return false;
    }

    function isValid(x, y) {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    function calculateAdjacentMines() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (!grid[y][x].isMine) {
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const newX = x + dx;
                            const newY = y + dy;
                            if (isValid(newX, newY) && grid[newY][newX].isMine) {
                                count++;
                            }
                        }
                    }
                    grid[y][x].adjacentMines = count;
                    // Update data attribute for styling if cell exists
                     if (grid[y][x].element) {
                         grid[y][x].element.dataset.adjacentMines = count;
                     }
                } else {
                    grid[y][x].adjacentMines = -1; // Indicate mine internally
                     if (grid[y][x].element) {
                         grid[y][x].element.removeAttribute('data-adjacent-mines');
                     }
                }
            }
        }
    }

     function handleFirstClick(x, y) {
         // Don't place mines if they are already placed (e.g., loaded game)
         if (firstClick) {
             // Reset mine locations before placing new ones
             for(let r=0; r<height; ++r) {
                 for(let c=0; c<width; ++c) {
                     grid[r][c].isMine = false;
                 }
             }
             placeMines(x, y); // Place mines, potentially using No Guess logic
             startTimer();
             firstClick = false;
         }
     }

    function revealCell(x, y) {
        if (!isValid(x,y)) return; // Check bounds first

        const cell = grid[y][x];

        // Cannot reveal already revealed or flagged cells
        if (!cell || cell.isRevealed || cell.isFlagged || gameOver) return;

        if (firstClick) {
             handleFirstClick(x, y);
             // Recalculate cell after potential mine placement
             // Note: adjacentMines should be correct now
        }

        cell.isRevealed = true;
        cell.element.classList.remove('pressed', 'flagged'); // Ensure flag class is removed
        cell.element.classList.add('revealed');
         cell.element.textContent = ''; // Clear flag text if any

        if (cell.isMine) {
            cell.element.classList.add('mine-revealed', 'mine'); // Add 'mine' for potential styling
            cell.element.textContent = "";
            revealAllMines(x, y); // Pass coords of the clicked mine
            showMessage("Game Over!");
            stopTimer();
            gameOver = true;
        } else {
             // Only reveal adjacent mines count if > 0
            if (cell.adjacentMines > 0) {
                cell.element.textContent = cell.adjacentMines;
                // cell.element.dataset.adjacentMines = cell.adjacentMines; // Set for CSS styling
            } else {
                // Flood fill for 0s
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        revealCell(x + dx, y + dy); // Recursive call
                    }
                }
            }
        }
       checkWin();
    }

   // 'click' event handler PRIMARILY for TOUCH interactions now
   function handleClick(event) {
        // --- BUG FIX: Check ignoreNextClick FIRST ---
        if (ignoreNextClick) {
            ignoreNextClick = false; // Reset the flag
            return; // Prevent action after touch long press
        }
        // --- END BUG FIX ---

        if (gameOver) return;

        // Ignore left mouse clicks here (handled by mousedown/mouseup)
        if (event.pointerType === 'mouse' && event.button === 0) {
             return;
        }

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);
         if (!isValid(x,y)) return; // Check validity
        const cell = grid[y][x];

        // Handle revealing/chording based on touch settings
        if (cell.isRevealed) { // Handle chording
            if (chordMethod === 'doubleTap') {
                 handleDoubleTapChord(event);
            } else { // singleTap chord
                chord(x, y);
            }
        } else { // Handle revealing or initiating double tap flag
             if (flagMethod === 'doubleTap') {
                 handleDoubleTapFlag(event); // This handles both flag and reveal on timeout
             } else {
                 // For longPress or rightClick flag methods, a single tap always reveals
                 if (firstClick) {
                     handleFirstClick(x, y);
                 }
                 if (!cell.isFlagged) { // Don't reveal if flagged
                    revealCell(x, y);
                 }
             }
        }
    }

    function handleFlag(event) {
      if (gameOver) return;
      // Allow event object or coordinates
       let targetCell, x, y;
       if (event.target) {
           targetCell = event.target.closest('.cell');
           if (!targetCell) return;
            x = parseInt(targetCell.dataset.x);
            y = parseInt(targetCell.dataset.y);
       } else if (typeof event.x === 'number' && typeof event.y === 'number') {
            x = event.x;
            y = event.y;
            if (!isValid(x,y) || !grid[y][x] || !grid[y][x].element) return;
            targetCell = grid[y][x].element;
       } else {
           return; // Invalid event/coords
       }


       if (!isValid(x,y)) return; // Check validity
      const cell = grid[y][x];

      if (!cell.isRevealed) {
        if (cell.isFlagged) {
          cell.isFlagged = false;
          cell.element.classList.remove('flagged');
          cell.element.textContent = '';
          minesLeft++;
        } else if (minesLeft > 0) {
          cell.isFlagged = true;
          cell.element.classList.add('flagged');
          cell.element.textContent = ''; // Use standard flag emoji
          minesLeft--;
        } else {
          // Maybe provide feedback if trying to flag with no mines left?
        }
        updateMinesLeftDisplay();
      }
      // Check win only if the game hasn't ended due to this flag potentially being the last mine
      if(!gameOver) checkWin();
    }

     function chord(x, y){
        if (!isValid(x,y)) return; // Check bounds
        const cell = grid[y][x];
        if(!cell || !cell.isRevealed || cell.adjacentMines === 0 || gameOver) return;

        let flaggedNeighbors = 0;
        let neighborsToReveal = [];

        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const newX = x + dx;
                const newY = y + dy;
                 if (isValid(newX, newY)) {
                     const neighbor = grid[newY][newX];
                       if (neighbor.isFlagged) {
                           flaggedNeighbors++;
                       } else if (!neighbor.isRevealed) {
                           neighborsToReveal.push({x: newX, y: newY});
                       }
                  }
            }
          }

         // If the number of flagged neighbors matches the cell's number, reveal the rest
         if(flaggedNeighbors === cell.adjacentMines){
             neighborsToReveal.forEach(neighbor => {
                 //revealCell will handle checks for flags/revealed status again, just in case
                 revealCell(neighbor.x, neighbor.y);
             });
             // Check win after potential mass reveal
             checkWin();
         }
     }

     function revealAllMines(clickedX, clickedY) {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y][x];
                 if (!cell || !cell.element) continue;

                 cell.element.classList.remove('pressed'); // Ensure no cells look pressed

                 if (cell.isMine && !cell.isRevealed) {
                     // Only reveal mines that weren't the one clicked (unless it's the only one)
                     if (x !== clickedX || y !== clickedY) {
                         cell.element.classList.add('mine'); // Add 'mine' class for styling
                         cell.element.classList.add('revealed'); // Mark as revealed visually
                          cell.element.textContent = "";
                     }
                 } else if (cell.isFlagged && !cell.isMine) {
                     // Mark incorrectly placed flags
                     cell.element.classList.remove('flagged');
                     cell.element.classList.add('incorrect-flag');
                     cell.element.textContent = 'X';
                 }
            }
        }
    }

   function checkWin() {
      if (gameOver) return;
      let revealedCount = 0;
      let correctlyFlaggedMines = 0;
       let totalMines = 0;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
           if (grid[y] && grid[y][x]) {
               const cell = grid[y][x];
                if (cell.isMine) {
                    totalMines++;
                    if (cell.isFlagged) {
                        correctlyFlaggedMines++;
                    }
                }
                if (cell.isRevealed && !cell.isMine) {
                    revealedCount++;
                }
           } else {
                // Should not happen if grid is initialized correctly
                console.error("Grid error during win check at", x, y);
                return;
           }
        }
      }

      const totalNonMineSquares = width * height - numMines; // Use the setting `numMines`

      // Win condition: All non-mine squares are revealed
      if (revealedCount === totalNonMineSquares) {
          flagRemainingMines(); // Automatically flag any remaining mines
          stopTimer();
          updateLeaderboard();
          showMessage("You Win! Time: " + time + " seconds");
          gameOver = true;
            if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
            isLeftMouseDown = false;
      }
    }

    // Helper function to flag remaining mines on win
    function flagRemainingMines(){
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 if (grid[y] && grid[y][x] && grid[y][x].isMine && !grid[y][x].isFlagged) {
                     handleFlag({x: x, y: y}); // Use coordinate-based flag call
                 }
            }
        }
        updateMinesLeftDisplay(); // Update display after auto-flagging
    }


    function flagIncorrectlyPlaced(){
        // This logic is now integrated into revealAllMines and checkWin/flagRemainingMines
        // Keeping the function stub in case it's needed elsewhere later.
        // console.warn("flagIncorrectlyPlaced called - logic moved elsewhere.");
    }

    function startTimer() {
        if (!gameStarted) {
            gameStarted = true;
            time = 0; // Reset timer on start
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                if (!gameOver) { // Only increment if game is running
                     time++;
                     updateTimerDisplay();
                } else {
                    stopTimer(); // Stop interval if game ends unexpectedly
                }
            }, 1000);
        }
    }

    function stopTimer() {
       clearInterval(timerInterval);
       gameStarted = false; // Allow timer to restart on new game
    }

   // --- Refined Long Press Listener for Touch ---
   function addLongPressListener(element, callback) {
       let elementTouchTimerId = null; // Timer ID specific to this element's touch
       longPressFlaggedThisTouch = false; // Reset this flag for the element

       const handleTouchStart = (e) => {
            // Only trigger for single touch and if revealed
           const cellData = getCellData(element);
           if (e.touches.length === 1 && elementTouchTimerId === null && cellData && !cellData.isRevealed) {
                e.preventDefault(); // Prevent default actions like scrolling maybe?
               longPressFlaggedThisTouch = false; // Reset on new touch start
               ignoreNextClick = false;          // Reset ignore flag too
               elementTouchTimerId = setTimeout(() => {
                   longPressFlaggedThisTouch = true; // Set flag: timer completed
                   callback(e);                      // Execute the flag callback
                   ignoreNextClick = true;           // Set flag to ignore upcoming click
                   elementTouchTimerId = null;       // Timer is done
               }, longPressDelay);
           } else if (elementTouchTimerId !== null) {
                 // Clear timer if multiple touches start
                 clearTimeout(elementTouchTimerId);
                 elementTouchTimerId = null;
                 longPressFlaggedThisTouch = false;
                 ignoreNextClick = false;
           }
       };

       const handleTouchEnd = (e) => {
           if (elementTouchTimerId !== null) {
               // Timer was cleared *before* it completed (short tap)
               clearTimeout(elementTouchTimerId);
               elementTouchTimerId = null;
                // If a short tap happened, and it wasn't ignored, treat it as a click
                // The actual click event will handle the reveal/chord
           }
           if (longPressFlaggedThisTouch) {
                // Long press DID complete, try to prevent default action (click)
                e.preventDefault(); // Important to prevent click after flag
                longPressFlaggedThisTouch = false; // Reset for next interaction
                // ignoreNextClick is already true, handleClick will handle it
           }
           // else: Short tap occurred, let the subsequent 'click' event handle it.
       };

       const handleTouchMove = (e) => {
           if (elementTouchTimerId !== null) {
               // Check if movement is significant enough to cancel
               // Basic check: if touch moves outside the cell element's bounds
                const touch = e.touches[0];
                const rect = element.getBoundingClientRect();
                if (touch.clientX < rect.left || touch.clientX > rect.right ||
                    touch.clientY < rect.top || touch.clientY > rect.bottom) {
                    clearTimeout(elementTouchTimerId);
                    elementTouchTimerId = null;
                    longPressFlaggedThisTouch = false; // Move cancels long press
                    ignoreNextClick = false;         // Don't ignore click if moved
                 }
           }
       };

        // Add Touch Listeners: set passive: false on touchstart/touchend to allow preventDefault
       element.addEventListener('touchstart', handleTouchStart, { passive: false });
       element.addEventListener('touchend', handleTouchEnd, { passive: false });
       element.addEventListener('touchmove', handleTouchMove, { passive: true }); // Move can be passive

       // Store handlers for removal
       element._touchStartHandler = handleTouchStart;
       element._touchEndHandler = handleTouchEnd;
       element._touchMoveHandler = handleTouchMove;

       // Mouse long press is handled separately in handleCellMouseDown
       // Add mouseleave cleanup for mouse long press timer started in mousedown
        const handleMouseLeave = () => {
             clearTimeout(mouseLongPressTimerId); // Clear potential MOUSE timer
             mouseLongPressTimerId = null;
             longPressJustFinishedMouse = false; // Reset mouse flag
             if (isLeftMouseDown && pressedCellElement === element) { // If leaving the pressed cell
                element.classList.remove('pressed');
                // Keep pressedCellElement assigned until mouseup or mouseover elsewhere
             }
        };
        element.addEventListener('mouseleave', handleMouseLeave);
        element._mouseLeaveHandlerLP = handleMouseLeave; // Store for removal
   }

   function removeLongPressListener(element) {
        // Clear any active touch timer associated with this element (if it exists conceptually)
        // Note: Direct access to elementTouchTimerId isn't feasible here, rely on cleanup elsewhere.

        if (element._touchStartHandler) {
            element.removeEventListener('touchstart', element._touchStartHandler, { passive: false }); // Match options
            delete element._touchStartHandler;
        }
        if (element._touchEndHandler) {
            element.removeEventListener('touchend', element._touchEndHandler, { passive: false }); // Match options
            delete element._touchEndHandler;
        }
        if (element._touchMoveHandler) {
            element.removeEventListener('touchmove', element._touchMoveHandler, { passive: true });
            delete element._touchMoveHandler;
        }
         // Remove mouse leave listener added by this function
         if (element._mouseLeaveHandlerLP) {
             element.removeEventListener('mouseleave', element._mouseLeaveHandlerLP);
             delete element._mouseLeaveHandlerLP;
         }
    }
    // --- END Refined Long Press ---


    function toggleSettings() {
        const settingsPanel = document.getElementById('settings-panel');
        const overlay = document.getElementById('overlay');
        if(settingsPanel.style.display === "block") {
            settingsPanel.style.display = "none";
            overlay.style.display = 'none';
        }
        else {
            settingsPanel.style.display = "block";
            overlay.style.display = 'block';
            // Update displayed values when opening
            document.getElementById('long-press-delay-value').textContent = longPressDelay;
            document.getElementById('width').value = width;
            document.getElementById('height').value = height;
            document.getElementById('mines').value = numMines;
            document.getElementById('no-guess-mode').checked = noGuessMode;
            document.getElementById('light-mode').checked = document.body.classList.contains('light-mode');
            document.getElementById('flag-method').value = flagMethod;
            document.getElementById('long-press-delay').value = longPressDelay;
            document.getElementById('chord-method').value = chordMethod;
            document.getElementById('player-name').value = playerName;

             // Show/hide custom settings based on current difficulty
            if (currentDifficulty === 'custom') {
               document.querySelector('.custom-settings').classList.add('active');
            } else {
               document.querySelector('.custom-settings').classList.remove('active');
            }
        }
    }
    function updateTimerDisplay(){
        const timerDiv = document.querySelector('#timer > div:nth-child(2)');
        if (timerDiv) {
            timerDiv.textContent = time;
        }
    }
    function updateMinesLeftDisplay(){
        const minesLeftDiv = document.querySelector('#mines-left > div:nth-child(2)');
         if (minesLeftDiv) {
            minesLeftDiv.textContent = minesLeft < 0 ? 0 : minesLeft; // Prevent negative display
         }
    }

    function setDifficulty(difficulty) {
      currentDifficulty = difficulty;
      const customSettings = document.querySelector('.custom-settings');
      let changed = false;

      switch (difficulty) {
        case 'beginner':
            if (width !== 9 || height !== 9 || numMines !== 10) changed = true;
            width = 9; height = 9; numMines = 10;
            customSettings.classList.remove('active');
            break;
        case 'intermediate':
             if (width !== 16 || height !== 16 || numMines !== 40) changed = true;
            width = 16; height = 16; numMines = 40;
            customSettings.classList.remove('active');
            break;
        case 'expert':
             if (width !== 30 || height !== 16 || numMines !== 99) changed = true;
            width = 30; height = 16; numMines = 99;
            customSettings.classList.remove('active');
            break;
        case 'custom':
          customSettings.classList.add('active');
            // Don't change w/h/n here, let user input them or keep current custom values
            // Update input fields to reflect current custom values
            document.getElementById('width').value = width;
            document.getElementById('height').value = height;
            document.getElementById('mines').value = numMines;
            // No restart needed just for selecting custom, only on apply
            return;
      }
        // Update input fields for non-custom difficulties too
        document.getElementById('width').value = width;
        document.getElementById('height').value = height;
        document.getElementById('mines').value = numMines;

        // Restart only if dimensions/mines actually changed
        if (changed) {
            minesLeft = numMines;
            restartGame();
        }
    }

   function applySettings() {
        let needsRestart = false;
        const prevWidth = width;
        const prevHeight = height;
        const prevNumMines = numMines;
        const prevNoGuess = noGuessMode;

        if (currentDifficulty === 'custom') {
            const newWidth = parseInt(document.getElementById('width').value);
            const newHeight = parseInt(document.getElementById('height').value);
            const newNumMines = parseInt(document.getElementById('mines').value);

             // Validate custom settings
             if (isNaN(newWidth) || newWidth < 5 || newWidth > 30) { alert('Width must be between 5 and 30.'); return; }
             if (isNaN(newHeight) || newHeight < 5 || newHeight > 30) { alert('Height must be between 5 and 30.'); return; }
              // Ensure at least one non-mine square for the first click safe zone (9 squares)
             const maxMines = (newWidth * newHeight) - 9;
             if (isNaN(newNumMines) || newNumMines < 1 || newNumMines > maxMines) { alert(`Mines must be between 1 and ${maxMines} for this grid size.`); return; }

             if (newWidth !== prevWidth || newHeight !== prevHeight || newNumMines !== prevNumMines) {
                 width = newWidth;
                 height = newHeight;
                 numMines = newNumMines;
                 needsRestart = true;
             }
        }

        // --- No Guess Mode ---
        const noGuessCheckbox = document.getElementById('no-guess-mode');
        noGuessMode = noGuessCheckbox.checked;
        if(noGuessMode !== prevNoGuess) {
            needsRestart = true; // Changing guess mode requires restart
        }
        localStorage.setItem('noGuessMode', noGuessMode ? 'enabled' : 'disabled');


        playerName = document.getElementById('player-name').value.trim() || "Player";
        localStorage.setItem('playerName', playerName);
        document.getElementById('player-name').value = playerName; // Update input field in case it was trimmed

        const lightModeCheckbox = document.getElementById('light-mode');
        const prevFlagMethod = flagMethod;
        const prevLongPressDelay = longPressDelay;
        const prevChordMethod = chordMethod;

        flagMethod = document.getElementById('flag-method').value;
        longPressDelay = parseInt(document.getElementById('long-press-delay').value);
        chordMethod = document.getElementById('chord-method').value;

        localStorage.setItem('lightMode', lightModeCheckbox.checked ? 'enabled' : 'disabled'); // Corrected key name
        localStorage.setItem('flagMethod', flagMethod);
        localStorage.setItem('longPressDelay', longPressDelay);
        localStorage.setItem('chordMethod', chordMethod);
        localStorage.setItem('currentDifficulty', currentDifficulty);
        localStorage.setItem('width', width);
        localStorage.setItem('height', height);
        localStorage.setItem('numMines', numMines);


        if (lightModeCheckbox.checked) {
            document.body.classList.add('light-mode');
        } else {
            document.body.classList.remove('light-mode');
        }
         // Update background colors immediately
         document.getElementById('settings-panel').style.backgroundColor = `var(--container-bg)`;
         document.getElementById('message-box').style.backgroundColor = `var(--container-bg)`;

         // Check if interaction methods changed that require updating listeners
         if (flagMethod !== prevFlagMethod || longPressDelay !== prevLongPressDelay || chordMethod !== prevChordMethod) {
             updateFlagMethod(); // Update listeners on all cells
         }


        if(needsRestart) {
            minesLeft = numMines;
            restartGame();
        }
        toggleSettings(); // Close settings panel
    }

    function showMessage(message) {
        document.getElementById('message-text').textContent = message;
        document.getElementById('message-box').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
    }

    function restartGame() {
        stopTimer();
        time = 0;
        updateTimerDisplay();
        gameStarted = false;
        firstClick = true;
        gameOver = false;
        minesLeft = numMines
        updateMinesLeftDisplay();

        // Reset ALL interaction states thoroughly
        ignoreNextClick = false;
        longPressFlaggedThisTouch = false; // Reset touch flag
        longPressJustFinishedMouse = false; // Reset mouse flag
        isLeftMouseDown = false;
         if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
         initialMouseDownCell = null;
        clearTimeout(touchLongPressTimerId); touchLongPressTimerId = null; // Clear touch timer
        clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null; // Clear mouse timer
        clearTimeout(doubleTapFlagTimer); doubleTapFlagTimer = null;
        clearTimeout(doubleTapChordTimer); doubleTapChordTimer = null;

        // Remove the global mouseup listener before creating the grid again
        document.removeEventListener('mouseup', handleDocumentMouseUp);

        createGrid(); // Recreate grid and reattach listeners
        // Re-apply interaction listeners based on current settings AFTER grid creation
        updateFlagMethod();

        document.getElementById('message-box').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
    }

    document.getElementById('long-press-delay').addEventListener('input', (event) => {
        document.getElementById('long-press-delay-value').textContent = event.target.value;
        // Update immediately for touch listeners if needed, though applying settings is safer
        // longPressDelay = parseInt(event.target.value);
    });

      function updateLeaderboard() {
        if (!db) { // Check if Firestore is available
             console.warn("Firestore not available, skipping online leaderboard update.");
             // Update local leaderboard regardless
             updateLocalLeaderboard();
             return;
         }
        if (noGuessMode) return; // Don't submit scores for no-guess mode

        if (currentDifficulty === 'beginner' || currentDifficulty === 'intermediate' || currentDifficulty === 'expert') {
            const currentName = document.getElementById('player-name').value.trim();
             if (!currentName) {
                 console.log("No player name set, skipping online submission.");
                 // Update local leaderboard even without name
                 updateLocalLeaderboard();
                 return;
             }

             // Check for impossibly low times (e.g., < 1 second) - likely cheating or error
             if (time < 1) {
                 console.log("Score too low, skipping online submission.");
                 updateLocalLeaderboard(); // Still update local
                 return;
             }


            const scoresCollection = db.collection('leaderboard');
            scoresCollection.add({
                playerName: currentName, difficulty: currentDifficulty, score: time,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => {
                console.log("Score submitted to online leaderboard!");
                loadOnlineLeaderboard(); // Refresh leaderboard after submission
            }).catch((error) => {
                console.error("Error submitting score: ", error);
                document.getElementById('leaderboard-error').textContent = 'Error submitting score.';
                document.getElementById('leaderboard-error').style.display = 'block';
            });

             // Update local leaderboard after attempting online submission
             updateLocalLeaderboard();
        }
    }

    // --- Helper to update just the local part ---
     function updateLocalLeaderboard() {
         if (currentDifficulty === 'beginner' || currentDifficulty === 'intermediate' || currentDifficulty === 'expert') {
             if (noGuessMode) return; // No local leaderboard for no-guess mode either

             let bestTime = localStorage.getItem(`leaderboard-${currentDifficulty}`);
             let changed = false;
             if (bestTime === null || time < parseInt(bestTime)) {
                 // Only update local storage if the new time is better or non-existent
                 if (time >= 1) { // Basic sanity check for local score too
                     localStorage.setItem(`leaderboard-${currentDifficulty}`, time);
                     bestTime = time;
                     changed = true;
                 }
             }
             // Always update the display element to show the current best (or '-')
             const tdElement = document.getElementById(`leaderboard-${currentDifficulty}-local`);
             if (tdElement) {
                 tdElement.textContent = bestTime === null ? '-' : bestTime + 's';
             }
         }
     }

async function fetchScoresRecursive(difficulty, targetCount, collectedScores = [], lastVisible = null) {
     if (!db) return []; // Return empty if DB not available

    // Define the base query
    let q = db.collection('leaderboard')
              .where('difficulty', '==', difficulty)
              .where('score', '>', 0) // Filter scores > 0 directly in Firestore
              .orderBy('score', 'asc')
              .orderBy('timestamp', 'asc'); // Secondary sort by timestamp for ties


    // If we have a document to start after (for pagination)
    if (lastVisible) {
        q = q.startAfter(lastVisible);
    }

    // Fetch a batch. Fetching slightly more than needed in case some future filter was added,
    // but with score > 1 in the query, we could calculate the exact remaining need.
    // Let's fetch batches of 'targetCount' for simplicity in this example.
    q = q.limit(targetCount); // Fetch up to targetCount in this batch

    try {
        const documentSnapshots = await q.get();

        // Get the last document for the next potential fetch
        const newLastVisible = documentSnapshots.docs[documentSnapshots.docs.length - 1];
        let addedCount = 0;
        let currentNames = new Set(collectedScores.map(s => s.playerName)); // Keep track of names already added

        documentSnapshots.forEach((doc) => {
            const data = doc.data();
            // Add scores to our collected list if we haven't reached the target yet
            // AND if the player isn't already in the list (ensures unique players)
            if (collectedScores.length < targetCount && !currentNames.has(data.playerName)) {
                collectedScores.push(data);
                currentNames.add(data.playerName); // Add name to the set
                addedCount++;
            }
        });

        // If we haven't reached the target count AND we received documents in this batch
        // (implying there might be more relevant scores), fetch the next batch.
        if (collectedScores.length < targetCount && addedCount > 0 && documentSnapshots.docs.length > 0 && newLastVisible) {
             // console.log(`Fetching more for ${difficulty}. Found ${collectedScores.length}, need ${targetCount}`);
             return fetchScoresRecursive(difficulty, targetCount, collectedScores, newLastVisible);
        } else {
             // We have enough scores OR there are no more documents to fetch
             // console.log(`Finished fetching for ${difficulty}. Found ${collectedScores.length}`);
             return collectedScores; // Return the final list
        }
    } catch (error) {
        console.error(`Error fetching scores for ${difficulty}:`, error);
        if (error.code === 'permission-denied' || error.code === 'unauthenticated') {
             document.getElementById('leaderboard-error').textContent = 'Online leaderboards disabled (auth error).';
             document.getElementById('leaderboard-error').style.display = 'block';
        } else if (error.code === 'unavailable'){
             document.getElementById('leaderboard-error').textContent = 'Online leaderboards unavailable (network).';
             document.getElementById('leaderboard-error').style.display = 'block';
        }
        throw error; // Re-throw the error to be caught by the main function
    }
}


async function loadOnlineLeaderboard() {
     if (!db) { // Check if Firestore is available
         document.getElementById('leaderboard-loading').style.display = 'none';
         // Keep potential error message from initialization visible
         return;
      }

    document.getElementById('leaderboard-loading').style.display = 'block';
    document.getElementById('leaderboard-error').style.display = 'none';
    document.getElementById('leaderboard-beginner').innerHTML = '';
    document.getElementById('leaderboard-intermediate').innerHTML = '';
    document.getElementById('leaderboard-expert').innerHTML = '';

    const difficulties = ['beginner', 'intermediate', 'expert'];
    const targetScoreCount = 10; // We want 10 scores per difficulty

    // Use Promise.allSettled to handle potential errors in individual fetches
    try {
        const results = await Promise.allSettled(
            difficulties.map(async (difficulty) => {
                const leaderboardBody = document.getElementById(`leaderboard-${difficulty}`);
                if (!leaderboardBody) {
                    console.error("Leaderboard body not found for:", difficulty);
                    throw new Error(`DOM element missing for ${difficulty}`);
                }
                leaderboardBody.innerHTML = ''; // Clear previous entries

                // Fetch the required scores recursively
                const scores = await fetchScoresRecursive(difficulty, targetScoreCount);

                 // Sort by score as primary, timestamp secondary before display
                 // Firestore should handle primary sort, but JS sort ensures consistency
                 scores.sort((a, b) => {
                    if (a.score !== b.score) {
                        return a.score - b.score;
                    }
                    // Use timestamps if available for tie-breaking
                    const timeA = a.timestamp?.toMillis() || 0;
                    const timeB = b.timestamp?.toMillis() || 0;
                    return timeA - timeB;
                 });


                // Populate the table with the fetched scores
                let rank = 1;
                scores.forEach((data) => {
                    const row = leaderboardBody.insertRow();
                    row.insertCell().textContent = rank++;
                    // Sanitize player name before displaying
                    const nameCell = row.insertCell();
                    nameCell.textContent = data.playerName.replace(/</g, "<").replace(/>/g, ">").substring(0, 20); // Basic sanitization + length limit
                    row.insertCell().textContent = data.score + 's';
                });

                if (scores.length === 0) {
                    const row = leaderboardBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 3;
                    cell.textContent = "-";
                    cell.style.textAlign = 'center';
                }
                return { difficulty, status: 'fulfilled' }; // Return success status
            })
        );

        // Check results for any failures
        let encounteredError = false;
        results.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`Error loading online leaderboard for ${difficulties[index]}:`, result.reason);
                encounteredError = true;
            }
        });

        if (encounteredError) {
             document.getElementById('leaderboard-error').textContent = 'Error loading some online leaderboards.';
             document.getElementById('leaderboard-error').style.display = 'block';
        }

        // Hide loading indicator after all promises settled
        document.getElementById('leaderboard-loading').style.display = 'none';

    } catch (error) {
        // Catch errors not handled by allSettled (e.g., issues before promises start)
        console.error("Unexpected error loading online leaderboards:", error);
        document.getElementById('leaderboard-loading').style.display = 'none';
        document.getElementById('leaderboard-error').textContent = 'Error loading online leaderboards.';
        document.getElementById('leaderboard-error').style.display = 'block';
    }
}


    function loadLeaderboard() {
        const difficulties = ['beginner', 'intermediate', 'expert'];
        difficulties.forEach(difficulty => {
            const bestTime = localStorage.getItem(`leaderboard-${difficulty}`);
            const tdElement = document.getElementById(`leaderboard-${difficulty}-local`); // Get TD element
             if (tdElement) { // Check if element exists
                 tdElement.textContent = bestTime === null ? '-' : bestTime + 's';
             }
        });
    }

    function loadSettings() {
      playerName = localStorage.getItem('playerName') || 'Player';
      document.getElementById('player-name').value = playerName;

       // --- Light/Dark Mode ---
      const savedLightMode = localStorage.getItem('lightMode'); // Corrected key
      const lightModeCheckbox = document.getElementById('light-mode');
      if (savedLightMode === 'enabled') {
          document.body.classList.add('light-mode');
          lightModeCheckbox.checked = true;
      } else {
           document.body.classList.remove('light-mode');
           lightModeCheckbox.checked = false;
      }
      // Update component backgrounds based on loaded theme
      document.getElementById('settings-panel').style.backgroundColor = `var(--container-bg)`;
      document.getElementById('message-box').style.backgroundColor = `var(--container-bg)`;


       // --- No Guess Mode ---
       const savedNoGuessMode = localStorage.getItem('noGuessMode');
       noGuessMode = (savedNoGuessMode === 'enabled');
       document.getElementById('no-guess-mode').checked = noGuessMode;


      // --- Interaction Settings ---
      flagMethod = localStorage.getItem('flagMethod') || 'longPress';
      document.getElementById('flag-method').value = flagMethod;
      longPressDelay = parseInt(localStorage.getItem('longPressDelay')) || 500;
      document.getElementById('long-press-delay').value = longPressDelay;
      document.getElementById('long-press-delay-value').textContent = longPressDelay;

      chordMethod = localStorage.getItem('chordMethod') || 'singleTap';
      document.getElementById('chord-method').value = chordMethod;

       // --- Difficulty and Dimensions ---
       // Load dimension/mine settings *before* setting difficulty
      width = parseInt(localStorage.getItem('width')) || 9;
      height = parseInt(localStorage.getItem('height')) || 9;
      numMines = parseInt(localStorage.getItem('numMines')) || 10;
      currentDifficulty = localStorage.getItem('currentDifficulty') || 'beginner';

      // Apply loaded difficulty - this might override w/h/m if not custom
      // setDifficulty will call restartGame if necessary based on *its* logic
      setDifficulty(currentDifficulty);

      // Ensure custom fields are updated if loaded difficulty was custom
      if(currentDifficulty === 'custom'){
           document.getElementById('width').value = width;
           document.getElementById('height').value = height;
           document.getElementById('mines').value = numMines;
            document.querySelector('.custom-settings').classList.add('active');
      } else {
           document.querySelector('.custom-settings').classList.remove('active');
      }

       // Make sure minesLeft matches loaded numMines before potential restart
       minesLeft = numMines;

      // Ensure interaction listeners match loaded settings *after* potential restart
      // RestartGame calls createGrid which adds basic listeners, then we update them fully here.
      updateFlagMethod();
    }

    // --- Initialize ---
    loadSettings(); // Loads settings, sets difficulty, potentially restarts
    loadLeaderboard(); // Load local scores
    loadOnlineLeaderboard(); // Load online scores (handles db check internally)
    // createGrid() is called by loadSettings -> setDifficulty -> restartGame (if needed)
    // If restartGame wasn't called, we need an initial grid create.
    if (grid.length === 0) {
        restartGame(); // Ensure grid is created on initial load if settings didn't trigger it
    }


    </script>
</body>
</html>