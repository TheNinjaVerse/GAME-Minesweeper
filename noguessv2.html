<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minesweeper</title>
    <!-- Firebase App (include only once) -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4; /* Steel Blue */
            --flagged-cell-color: #FFD700; /* Gold */
            --mine-bg-color: #B22222; /* Firebrick */
            --mine-revealed-bg: #800000; /* Maroon */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D; /* Sienna */
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */

             /* Dark mode number colors (lighter) */
            --num-1-color-dark: #ADD8E6; /* Light Blue */
            --num-2-color-dark: #90EE90; /* Light Green */
            --num-3-color-dark: #F08080; /* Light Coral */
            --num-4-color-dark: #B0C4DE; /* Light Steel Blue */
            --num-5-color-dark: #FFA07A; /* Light Salmon */
            --num-6-color-dark: #20B2AA; /* Light Sea Green */
            --num-7-color-dark: #E6E6FA; /* Lavender (lighter than grey) */
            --num-8-color-dark: #D3D3D3; /* Light Gray */
        }

        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB; /* Sky Blue */
            --flagged-cell-color: #B22222; /* Firebrick */
            --mine-bg-color: #F08080; /* Light Coral */
            --mine-revealed-bg: #DC143C; /* Crimson */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700; /* Gold */
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell */
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }
         #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--container-bg);
            padding: 10px;
        }

        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
             user-select: none;
             -webkit-tap-highlight-color: transparent;
             /* touch-action: manipulation; might also be helpful here */
        }

        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        .cell.mine { /* Style for the mine hit that ends the game */
             background-color: red !important; /* Make it stand out */
             color: white;
        }
        .cell.mine-revealed {
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }

        /* Dark Mode Number colors */
        .cell[data-adjacent="1"] { color: var(--num-1-color-dark); }
        .cell[data-adjacent="2"] { color: var(--num-2-color-dark); }
        .cell[data-adjacent="3"] { color: var(--num-3-color-dark); }
        .cell[data-adjacent="4"] { color: var(--num-4-color-dark); }
        .cell[data-adjacent="5"] { color: var(--num-5-color-dark); }
        .cell[data-adjacent="6"] { color: var(--num-6-color-dark); }
        .cell[data-adjacent="7"] { color: var(--num-7-color-dark); }
        .cell[data-adjacent="8"] { color: var(--num-8-color-dark); }

        /* Light mode number colors (standard/original) */
        .light-mode .cell[data-adjacent="1"] { color: blue; }
        .light-mode .cell[data-adjacent="2"] { color: green; }
        .light-mode .cell[data-adjacent="3"] { color: red; }
        .light-mode .cell[data-adjacent="4"] { color: navy; }
        .light-mode .cell[data-adjacent="5"] { color: maroon; }
        .light-mode .cell[data-adjacent="6"] { color: teal; }
        .light-mode .cell[data-adjacent="7"] { color: black; }
        .light-mode .cell[data-adjacent="8"] { color: gray; }


        #controls {
            display: flex;
            justify-content: space-around;
            width: 90%;
            margin-bottom: 10px;
            align-items: center;
        }

        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }

        #settings {
            margin-top: 20px;
        }

        #settings button {
            padding: 10px 20px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings button:hover {
            background-color: var(--button-hover-bg);
        }

          #settings-panel {
            display: none;
            position: fixed;
            top: 50%; /* Start at 50% */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            width: 90%;
            max-width: 450px;
            border-radius: 12px;
            overflow-y: auto;  /* Enable vertical scrolling */
            max-height: 80vh; /* Limit height to 80% of viewport height */

        }
        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }

        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"] { /* Apply styles to text input too */
            width: 70px;
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 5px;
            font-size: 1em;
        }
         #settings-panel input[type="text"]{
             width: calc(100% - 20px); /* Take full width minus padding */
         }

        #settings-panel input[type="range"] {
            width: 100%;
        }

        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings-panel button:hover {
            background-color: var(--button-hover-bg);;
        }

        #settings-panel .setting-group {
           margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
          #settings-panel .difficulty-buttons {
            display: flex;
            justify-content: space-between; /* Evenly space buttons */
            margin-bottom: 15px;
        }
          #settings-panel .difficulty-buttons button {
            flex: 1; /* Each button takes equal width */
            margin: 0 5px; /* Space between buttons */
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 999;
        }

        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }

        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;

        }

        /* Toggle switch styles */
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
          margin-bottom: 12px;
          vertical-align: middle; /* Align with label */
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 34px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(26px);
          -ms-transform: translateX(26px);
          transform: translateX(26px);
        }
        #settings-panel select{
            margin-bottom: 10px;
            padding: 5px;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            margin: 0 auto;
            border-collapse: collapse;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
        }
        .custom-settings {
            display: none; /* Initially hidden */
        }

        .custom-settings.active {
            display: block; /* Show when active */
        }
         #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            margin: 0 auto;
            border-collapse: collapse;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
       }
      #leaderboard-loading {
          margin-bottom: 10px;
      }
       /* Style for online leaderboard tables */
      #online-leaderboard-container {
        display: flex; /* Use flexbox for side-by-side tables */
        justify-content: space-around; /* Distribute space evenly */
        flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
        width: 90%;
        margin: 20px auto;

      }

      #online-leaderboard-container table {
        width: 45%; /* Each table takes roughly half the container width */
        margin-bottom: 20px; /* Space between tables */
        border-collapse: collapse;
         box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
        #online-leaderboard-container th,
        #online-leaderboard-container td {
             padding: 8px;
              border: 1px solid var(--control-border-color);
              text-align: center;
        }
        #online-leaderboard-container th {
             background-color: var(--control-bg-color);
              color: var(--text-color);
               font-weight: bold;
        }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        #online-leaderboard-container {
          flex-direction: column; /* Stack tables vertically on smaller screens */
        }
          #online-leaderboard-container table {
            width: 90%; /* Tables take full width on smaller screens */
             margin: 10px auto;
          }
      }
       #generation-attempts {
         margin-left: 10px;
         font-size: 0.9em;
         color: #aaa; /* Light gray color */
        }
        .light-mode #generation-attempts {
            color: #555; /* Darker gray for light mode */
        }


    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls">
            <div id="mines-left">
                <div id="mines-left-label">Mines</div>
                <div></div>
            </div>
            <div id="timer">
                 <div id="timer-label">Timer</div>
                <div>0</div>
            </div>
        </div>
        <div id="grid-container"></div>
    </div>
    <div id="settings">
        <button onclick="toggleSettings()">Settings</button>
    </div>

      <div id="settings-panel">
        <h2>Settings</h2>
        <div class="setting-group difficulty-buttons">
            <button onclick="setDifficulty('beginner')">Beginner</button>
            <button onclick="setDifficulty('intermediate')">Intermediate</button>
            <button onclick="setDifficulty('expert')">Expert</button>
            <button onclick="setDifficulty('custom')">Custom</button> <!-- Custom Difficulty Button -->
        </div>
        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>

        <div class="custom-settings setting-group">
            <label for="width">Width:</label>
            <input type="number" id="width" min="5" max="50" value="9"> <!-- Increased max size -->
            <label for="height">Height:</label>
            <input type="number" id="height" min="5" max="50" value="9"> <!-- Increased max size -->
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="2491" value="10"> <!-- Max mines adjusted based on max w/h -->
        </div>
        <div class="setting-group">
             <label for="light-mode" style="display: inline-block; margin-right: 10px;">Light Mode:</label>
             <label class="switch">
                <input type="checkbox" id="light-mode">
                <span class="slider"></span>
             </label>
        </div>
        <div class="setting-group">
             <label for="no-guess-mode" style="display: inline-block; margin-right: 10px;">No Guess Mode:</label>
             <label class="switch">
                 <input type="checkbox" id="no-guess-mode">
                 <span class="slider"></span>
             </label>
             <span id="generation-attempts"></span> <!-- To display attempts -->
        </div>

        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method" onchange="updateFlagMethod()">
              <option value="longPress">Long Press</option>
              <option value="doubleTap">Double Tap</option>
              <option value="rightClick">Right Click</option>
            </select>
        </div>

        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>

        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        <button onclick="applySettings()">Apply</button>
        <button onclick="toggleSettings()">Close</button>
    </div>

    <div id="overlay"></div>
     <div id="message-box">
      <p id="message-text"></p>
      <button onclick="restartGame()">Restart</button>
    </div>
      <div id="online-leaderboard-container">
        <div id="leaderboard-loading">Loading leaderboards...</div>
        <div id="leaderboard-error" style="color: red; display: none;">Error loading leaderboards.</div>

        <table>
            <thead><tr><th colspan="3">Beginner</th></tr></thead>
            <tbody id="leaderboard-beginner"></tbody>
        </table>

        <table>
             <thead><tr><th colspan="3">Intermediate</th></tr></thead>
            <tbody id="leaderboard-intermediate"></tbody>
        </table>

        <table>
            <thead><tr><th colspan="3">Expert</th></tr></thead>
            <tbody id="leaderboard-expert"></tbody>
        </table>
      </div>

      <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best Time</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Beginner</td>
                    <td id="leaderboard-beginner-local">-</td>
                </tr>
                <tr>
                    <td>Intermediate</td>
                    <td id="leaderboard-intermediate-local">-</td>
                </tr>
                <tr>
                    <td>Expert</td>
                    <td id="leaderboard-expert-local">-</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
     // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAV_27osmUzqrYbJIatByVHigyKh0naSNM",
      authDomain: "min3s-d13d8.firebaseapp.com",
      projectId: "min3s-d13d8",
      storageBucket: "min3s-d13d8.firebasestorage.app",
      messagingSenderId: "561325595032",
      appId: "1:561325595032:web:19657730940427fb4073ed",
      measurementId: "G-N25M3ZT9NQ"
    };

    // Initialize Firebase
    const firebaseApp = firebase.initializeApp(firebaseConfig);
    const db = firebaseApp.firestore();

    let grid = [];
    let width = 9;
    let height = 9;
    let numMines = 10;
    let minesLeft = numMines;
    let timerInterval;
    let time = 0;
    let gameStarted = false;
    let gameOver = false;
    let firstClick = true;
    let touchLongPressTimerId = null;
    let mouseLongPressTimerId = null;
    let ignoreNextClick = false; // Flag to ignore click after long press
    let longPressFlaggedThisTouch = false; // Flag set when touch long press timer completes
    let longPressJustFinishedMouse = false; // Flag for mouse long press completion
    let isLeftMouseDown = false;
    let pressedCellElement = null;
    let initialMouseDownCell = null;
    let longPressDelay = 500;
    let flagMethod = "longPress";
    let chordMethod = "singleTap";
    let doubleTapChordTimer = null;
    let doubleTapFlagTimer = null;
    let currentDifficulty = "beginner";
    let playerName = "Player";
    let noGuessMode = false; // Added for No Guess Mode
    let generationAttempts = 0; // Added for No Guess Mode


    function createGrid() {
      const gridContainer = document.getElementById('grid-container');
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
      grid = [];

      for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleClick); // Handles taps
          cell.addEventListener('mousedown', handleCellMouseDown); // Handles mouse down (incl. long press start)
          cell.addEventListener('contextmenu', handleRightClick); // Handles right click flag
          cell.addEventListener('mouseover', handleCellMouseOver); // Handles mouse drag over cells
          cell.addEventListener('mouseout', handleCellMouseOut); // Handles mouse leaving cell while down

          // Apply touch/long press listeners based on settings
          updateFlagMethod(cell, x, y); // Attaches specific touch listeners

          gridContainer.appendChild(cell);
          grid[y][x] = {
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            adjacentMines: 0,
            element: cell,
          };
        }
      }
      updateMinesLeftDisplay();
      updateTimerDisplay();
      // Prevent default context menu on the grid
      gridContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); });
      // Global mouseup listener for releasing clicks outside the grid
      document.addEventListener('mouseup', handleDocumentMouseUp);
    }

    function handleRightClick(event) {
      event.preventDefault(); // Prevent browser context menu
       if (flagMethod === 'rightClick') {
           handleFlag(event); // Handle flag if method is right click
       }
    }

    function handleCellMouseDown(event) {
        if (gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        initialMouseDownCell = targetCell; // Store the cell where mouse down started

        // --- Right Click (Button 2) ---
        if (event.button === 2) {
            event.preventDefault(); // Prevent context menu
            if (flagMethod === 'rightClick') {
                // Flag is handled by handleRightClick, which calls handleFlag
            } else if (flagMethod === 'longPress') {
                 // Allow right-click flagging even if long press is the primary mobile method
                 handleFlag(event);
            }
            return; // Don't process as left click
        }

        // --- Left Click (Button 0) ---
        if (event.button === 0) {
             // --- Long Press Handling (for mouse) ---
             if (flagMethod === 'longPress') {
                 clearTimeout(mouseLongPressTimerId); // Clear previous timer
                 longPressJustFinishedMouse = false; // Reset mouse long press flag
                 mouseLongPressTimerId = setTimeout(() => {
                     // Timer completed: Long press detected for mouse
                     handleFlag(event); // Perform flag action
                     longPressJustFinishedMouse = true; // Set flag specific to mouse
                     mouseLongPressTimerId = null; // Timer is done
                     // Release the 'pressed' state since the action is complete
                     if (pressedCellElement) {
                        pressedCellElement.classList.remove('pressed');
                     }
                     pressedCellElement = null;
                 }, longPressDelay);
             }

             // --- Standard Left Mouse Down ---
             isLeftMouseDown = true;
             pressedCellElement = targetCell;
             const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
             // Only show 'pressed' style on unrevealed, unflagged cells
             if (!cellData.isRevealed && !cellData.isFlagged) {
                pressedCellElement.classList.add('pressed');
             }
        }
    }

    function handleCellMouseOver(event) {
        // Only apply hover effects if left mouse button is currently held down
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return; // Ignore if not hovering over a cell

        const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];

        // If hovering over a revealed cell, remove pressed state from any cell
        if (cellData.isRevealed) {
             if (pressedCellElement && pressedCellElement !== targetCell) {
                 pressedCellElement.classList.remove('pressed');
             }
             pressedCellElement = null; // No cell should appear pressed
             return;
        }

        // If hovering over a different unrevealed cell than the one currently pressed
        if (targetCell !== pressedCellElement) {
            if (pressedCellElement) { // Remove pressed state from the old cell
                pressedCellElement.classList.remove('pressed');
            }
            // Add pressed state to the new cell
            if (!cellData.isFlagged) { // Don't press flagged cells
                 targetCell.classList.add('pressed');
                 pressedCellElement = targetCell;
            } else {
                 pressedCellElement = null; // Don't visually press flagged cells
            }
        }
    }

    function handleCellMouseOut(event) {
        // Only apply if left mouse button is currently held down
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        // If moving out of the cell that was visually pressed
        if (targetCell === pressedCellElement) {
             pressedCellElement.classList.remove('pressed');
             // Keep track that a cell *was* pressed (initialMouseDownCell),
             // but remove the visual style when mouse leaves it.
             // Set pressedCellElement to null so mouseover another cell can press it.
             pressedCellElement = null;
        }
    }


    function handleDocumentMouseUp(event) {
         // --- Left Click Release (Button 0) ---
        if (event.button === 0 && isLeftMouseDown) {
             isLeftMouseDown = false; // Mouse button is up
             const mouseUpTargetElement = document.elementFromPoint(event.clientX, event.clientY);
             const mouseUpCellElement = mouseUpTargetElement ? mouseUpTargetElement.closest('.cell') : null;

             // Clear any running MOUSE long press timer (it didn't complete if we got here)
             clearTimeout(mouseLongPressTimerId);
             mouseLongPressTimerId = null;

             // Remove visual pressed state from the last pressed cell, if any
             if (pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
             }
             pressedCellElement = null; // Reset the currently visually pressed cell

             // --- Check if a MOUSE long press just finished ---
             if (longPressJustFinishedMouse) {
                 longPressJustFinishedMouse = false; // Reset mouse flag
                 initialMouseDownCell = null; // Reset initial cell
                 return; // Do not reveal/chord if mouse long press just flagged
             }

             if (gameOver) {
                 initialMouseDownCell = null;
                 return;
             }


             // --- Check if mouse was released over the *same cell* it was pressed down on ---
             if (mouseUpCellElement && mouseUpCellElement === initialMouseDownCell) {
                 const x = parseInt(mouseUpCellElement.dataset.x);
                 const y = parseInt(mouseUpCellElement.dataset.y);
                 const cellData = grid[y][x];

                 if (firstClick) {
                     handleFirstClick(x, y);
                 } else if (cellData.isRevealed) {
                     chord(x, y); // Perform chord action on revealed cell
                 } else if (!cellData.isFlagged) {
                     revealCell(x, y); // Reveal unrevealed, unflagged cell
                 }
             }
             initialMouseDownCell = null; // Reset initial cell tracking

        } else {
             // --- Handle non-left click mouseup or mouseup when not dragging ---
             if (pressedCellElement) { // Clean up visual state if needed
                  pressedCellElement.classList.remove('pressed');
                  pressedCellElement = null;
             }
             isLeftMouseDown = false; // Ensure state is reset
             clearTimeout(mouseLongPressTimerId); // Clear timer
             mouseLongPressTimerId = null;
             initialMouseDownCell = null; // Reset initial cell tracking
             longPressJustFinishedMouse = false; // Reset flag
        }
    }

    function handleFirstClick(x, y) {
         if (!firstClick || gameOver) return;

         const attemptsSpan = document.getElementById('generation-attempts');
         attemptsSpan.textContent = ''; // Clear previous attempts count

         if (noGuessMode) {
             generationAttempts = 0;
             let solvable = false;
             console.log("No Guess Mode: Starting generation...");
             attemptsSpan.textContent = 'Generating...';
             // Use setTimeout to avoid freezing the UI during generation
             setTimeout(() => {
                 while (!solvable) {
                     generationAttempts++;
                     // Reset mine flags before placing new ones
                     for (let r = 0; r < height; r++) {
                         for (let c = 0; c < width; c++) {
                             grid[r][c].isMine = false;
                             grid[r][c].adjacentMines = 0;
                         }
                     }
                     placeMines(x, y); // Place mines respecting safe zone
                     if (isSolvableWithoutGuessing(x, y)) {
                         solvable = true;
                         console.log(`No Guess Mode: Solvable grid found after ${generationAttempts} attempts.`);
                         attemptsSpan.textContent = `(${generationAttempts} attempts)`;
                         startTimer();
                         firstClick = false;
                         revealCell(x, y); // Reveal the first clicked cell
                     } else {
                        // Optional: Log attempts or provide feedback if it takes too long
                        if (generationAttempts % 100 === 0) {
                            console.log(`No Guess Mode: Attempt ${generationAttempts}...`);
                            attemptsSpan.textContent = `Generating... (${generationAttempts})`;
                        }
                        if (generationAttempts > 5000) { // Reduced safety break
                             console.error(`No Guess Mode: Generation timed out after ${generationAttempts} attempts.`);
                             alert(`Failed to generate a solvable grid in No Guess Mode after ${generationAttempts} tries. Try reducing density or grid size, or disable No Guess Mode.`);
                             attemptsSpan.textContent = '(Generation Failed)';
                             // Revert to normal mode for this game instance? Or just keep trying?
                             // Let's restart to avoid getting stuck
                             restartGame();
                             return; // Stop the generation loop
                        }
                     }
                 }
             }, 0); // Allow UI update before starting loop

         } else {
             // Normal mode: place mines once
             placeMines(x, y);
             startTimer();
             firstClick = false;
             revealCell(x, y); // Reveal the first clicked cell
         }
     }

    function updateFlagMethod(cell, x, y) {
        // If cell is not provided, update all cells
        if(!cell){
            for(let r = 0; r < height; r++){
                for(let c = 0; c < width; c++){
                    if (grid[r] && grid[r][c] && grid[r][c].element) {
                       updateFlagMethod(grid[r][c].element, c, r);
                    }
                }
            }
            return;
        }

        // Remove potentially existing listeners first to avoid duplicates
        cell.removeEventListener('touchstart', handleDoubleTapFlag);
        removeLongPressListener(cell); // Remove previous specific long press listeners

        // Add the listener based on the current setting
        if (flagMethod === 'longPress') {
            addLongPressListener(cell, handleFlag); // Adds TOUCH long press listener
        } else if (flagMethod === 'doubleTap') {
            cell.addEventListener('touchstart', handleDoubleTapFlag);
        } else if (flagMethod === 'rightClick') {
            // Right click is handled by handleCellMouseDown and handleRightClick
        }
    }

    function handleDoubleTapFlag(event){
        if(gameOver || flagMethod !== 'doubleTap') return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        if(doubleTapFlagTimer === null){
            // First tap: Set a timer. If it expires, it's a single tap (reveal).
            doubleTapFlagTimer = setTimeout(() => {
                doubleTapFlagTimer = null;
                // Don't call handleClick directly, let the natural click/mouseup handle reveal for single tap
            }, 300); // 300ms window for double tap
        }
        else{
            // Second tap within the window: This is a double tap (flag).
            clearTimeout(doubleTapFlagTimer); // Cancel the single tap timer
            doubleTapFlagTimer = null;
            handleFlag(event); // Perform flag action

            // --- Crucial: Prevent the subsequent 'click' event from revealing ---
             ignoreNextClick = true;

             // Also prevent mouseup from revealing if somehow triggered
             if(pressedCellElement){
                 pressedCellElement.classList.remove('pressed');
                 pressedCellElement = null;
             }
             isLeftMouseDown = false; // Ensure mouse up state is cleared
        }
    }
    function handleDoubleTapChord(event){
        if(gameOver || chordMethod !== 'doubleTap') return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);

         if (doubleTapChordTimer === null) {
             // First tap on revealed number: set timer
            doubleTapChordTimer = setTimeout(() => {
                doubleTapChordTimer = null;
                // Timeout means single tap, do nothing here (no default action needed)
            }, 300);
        } else {
            // Second tap: chord action
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
            chord(x, y);
             // Prevent click/mouseup if needed, though chord usually doesn't trigger reveal
             ignoreNextClick = true;
        }
    }

    // --- placeMines, isNearSafeZone, calculateAdjacentMines ---
    function placeMines(safeX, safeY) {
        let minesPlaced = 0;
        let availableSquares = [];
        // Create list of squares *not* in the 3x3 safe zone
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 let isSafe = false;
                 for(let dy = -1; dy <= 1; dy++){
                     for(let dx = -1; dx <= 1; dx++){
                         if(x === safeX + dx && y === safeY + dy){
                             isSafe = true;
                             break;
                         }
                     }
                     if(isSafe) break;
                 }
                 if (!isSafe) {
                     availableSquares.push({x, y});
                 }
            }
        }

        // Shuffle the available squares using Fisher-Yates
        for (let i = availableSquares.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSquares[i], availableSquares[j]] = [availableSquares[j], availableSquares[i]];
        }

        // Place mines in the first 'numMines' shuffled squares
        const minesToPlace = Math.min(numMines, availableSquares.length); // Ensure we don't try to place more mines than available spots
        for (let i = 0; i < minesToPlace; i++) {
            const { x, y } = availableSquares[i];
             if(grid[y] && grid[y][x]){ // Basic check
                 grid[y][x].isMine = true;
                 minesPlaced++;
             }
        }

         if (minesPlaced < numMines) {
             console.warn(`Could only place ${minesPlaced} out of ${numMines} mines due to safe zone size or grid constraints.`);
         } else if (minesPlaced > numMines) {
              console.error(`Placed too many mines (${minesPlaced})! Check logic.`);
         }

        calculateAdjacentMines();
    }


    function isNearSafeZone(x, y, safeX, safeY){ // Unused now, logic moved into placeMines
        for(let dx = -1; dx <= 1; dx++){
            for(let dy = -1; dy <= 1; dy++){
                if(x === safeX + dx && y === safeY + dy){
                    return true;
                }
            }
        }
        return false;
    }

    function calculateAdjacentMines() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (grid[y]?.[x] && !grid[y][x].isMine) { // Check cell exists
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const newX = x + dx;
                            const newY = y + dy;
                            // Check bounds and if the neighbor is a mine
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY]?.[newX]?.isMine) {
                                count++;
                            }
                        }
                    }
                    grid[y][x].adjacentMines = count;
                    // Update element data attribute if it exists (for styling)
                    if(grid[y][x].element) {
                         grid[y][x].element.dataset.adjacent = count;
                    }
                } else if (grid[y]?.[x]) {
                     grid[y][x].adjacentMines = -1; // Indicate a mine
                     if(grid[y][x].element) {
                          delete grid[y][x].element.dataset.adjacent; // Remove data attribute for mines
                     }
                }
            }
        }
    }

    function revealCell(x, y) {
        if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return; // Bounds check and game over check

        const cell = grid[y][x];
        if (!cell || cell.isRevealed || cell.isFlagged) return; // Check cell exists, already revealed or flagged

        cell.isRevealed = true;
        cell.element.classList.remove('pressed'); // Ensure pressed style is removed
        cell.element.classList.add('revealed');
        cell.element.classList.remove('flagged'); // Remove flag style if it was somehow revealed while flagged

        if (cell.isMine) {
            cell.element.classList.add('mine'); // Add the specific class for the hit mine
            revealAllMines(x, y); // Pass the clicked mine coordinates
            showMessage("Game Over!");
            stopTimer();
            gameOver = true;
        } else {
             cell.element.dataset.adjacent = cell.adjacentMines; // Set data attribute for styling
            if (cell.adjacentMines > 0) {
                cell.element.textContent = cell.adjacentMines;
            } else {
                // Propagate reveal for 0-mine neighbors
                 cell.element.textContent = ''; // Ensure empty for 0
                // Use a queue for non-recursive propagation to avoid stack overflow on large empty areas
                const revealQueue = [];
                revealQueue.push({nx: x, ny: y}); // Start with the current cell (already revealed, just for neighbors)

                while(revealQueue.length > 0) {
                    const current = revealQueue.shift();
                    // Reveal neighbors of the current ZERO cell
                     for (let dy = -1; dy <= 1; dy++) {
                         for (let dx = -1; dx <= 1; dx++) {
                             if (dx === 0 && dy === 0) continue;
                             const nextX = current.nx + dx;
                             const nextY = current.ny + dy;

                             if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {
                                 const neighborCell = grid[nextY][nextX];
                                 // Only reveal if it's not revealed and not flagged
                                 if (neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged) {
                                     neighborCell.isRevealed = true;
                                     neighborCell.element.classList.add('revealed');
                                     neighborCell.element.classList.remove('pressed');
                                     neighborCell.element.dataset.adjacent = neighborCell.adjacentMines; // Set data attr

                                     if (neighborCell.adjacentMines > 0) {
                                         neighborCell.element.textContent = neighborCell.adjacentMines;
                                     } else {
                                         neighborCell.element.textContent = '';
                                         // Add this new zero cell to the queue to process its neighbors
                                         revealQueue.push({nx: nextX, ny: nextY});
                                     }
                                 }
                             }
                         }
                     }
                }
            }
        }
       if (!gameOver) checkWin(); // Check win condition only if game not over
    }

   // 'click' event handler PRIMARILY for TOUCH interactions now
   function handleClick(event) {
        // --- Check ignoreNextClick FIRST ---
        // This is crucial to prevent reveal after long-press flag/unflag or double-tap flag
        if (ignoreNextClick) {
            ignoreNextClick = false; // Reset the flag for the next interaction
            return; // Stop processing this click/tap event
        }
        // --- END ignoreNextClick Check ---

        if (gameOver) return;

        // Ignore left mouse clicks (handled by mousedown/mouseup logic)
        if (event.pointerType === 'mouse' && event.button === 0) {
             return;
        }

        // --- Process Tap ---
        const targetCell = event.target.closest('.cell');
        if (!targetCell) return; // Exit if the click wasn't on a cell
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);

        if (firstClick) {
             handleFirstClick(x, y); // Use the dedicated first click handler
             return; // First click logic handles reveal/start/generation
        }

        const cell = grid[y][x];
        if (!cell) return; // Cell data doesn't exist?

        // Subsequent touch actions (or non-first clicks if any slip through)
        if (cell.isRevealed) { // Handle chording
            if (chordMethod === 'doubleTap') {
                 handleDoubleTapChord(event); // Needs its own timer/logic
            } else {
                chord(x, y); // Single tap chord
            }
        } else if (!cell.isFlagged) { // Handle revealing (only if not flagged)
             if (flagMethod === 'doubleTap') {
                  // In double-tap flag mode, a single tap should reveal.
                  // We check the timer state to ensure it's not the *first* tap
                  // of an intended double-tap-flag action.
                  if (doubleTapFlagTimer === null) {
                      // Timer is null, meaning it's either expired (was single tap)
                      // or hasn't started (this is the first tap). Reveal now.
                      revealCell(x, y);
                  }
                  // If timer is NOT null, it means this is the first tap of a potential
                  // double tap. Do nothing here; let the timeout in handleDoubleTapFlag
                  // handle the reveal if the second tap doesn't occur.
             } else {
                 // For long press or right click flag modes, a simple tap reveals.
                 revealCell(x, y);
             }
        }
        // If the cell IS flagged, a tap does nothing.
    }

    function handleFlag(event) {
      if (gameOver) return;

      const targetCell = event.target.closest('.cell');
      if (!targetCell) return;

      const x = parseInt(targetCell.dataset.x);
      const y = parseInt(targetCell.dataset.y);
      const cell = grid[y][x];

      if (!cell.isRevealed) { // Can only flag/unflag unrevealed cells
        if (cell.isFlagged) {
          // Unflag
          cell.isFlagged = false;
          cell.element.classList.remove('flagged');
          cell.element.textContent = '';
          minesLeft++;
        } else if (minesLeft > 0) { // Only allow flagging if mines are left
          // Flag
          cell.isFlagged = true;
          cell.element.classList.add('flagged');
          cell.element.textContent = 'ðŸš©';
          minesLeft--;
        } else {
             // No mines left to flag - maybe provide feedback? (optional)
              // console.log("Cannot flag, no mines left according to counter.");
        }
        updateMinesLeftDisplay();
        // Check win only needed if all mines might be flagged now
        if (minesLeft === 0) {
             checkWin();
        }
      }
    }

     function chord(x, y){
        if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return; // Bounds check and game over check

        const cell = grid[y]?.[x];
        // Only chord if the cell exists, is revealed, and has adjacent mines
        if(!cell || !cell.isRevealed || cell.adjacentMines === 0) return;

        let flaggedNeighbors = 0;
        let unknownAndUnflaggedNeighbors = []; // Keep track of neighbours to reveal

         for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const newX = x + dx;
                const newY = y + dy;
                 // Check bounds for neighbor
                 if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                      const neighbor = grid[newY]?.[newX];
                      if (neighbor) { // Check neighbor exists
                          if (neighbor.isFlagged) {
                               flaggedNeighbors++;
                          } else if (!neighbor.isRevealed) {
                               // Only add unrevealed AND unflagged neighbors to the list to be opened
                               unknownAndUnflaggedNeighbors.push({x: newX, y: newY});
                          }
                      }
                 }
            }
          }

         // If the number of adjacent flags matches the cell's number, reveal the rest
         if(flaggedNeighbors === cell.adjacentMines){
             unknownAndUnflaggedNeighbors.forEach(neighborPos => {
                 // Use revealCell to handle mine checks and propagation correctly
                 revealCell(neighborPos.x, neighborPos.y);
             });
         }
         // If chord fails (e.g., game ends due to hitting a mine), checkWin will be called within revealCell.
         // If chord succeeds without ending game, checkWin is needed here.
          if (!gameOver) checkWin(); // Check win condition after successful chord reveals
     }

     function revealAllMines(clickedX, clickedY) {
        gameOver = true; // Ensure game over state is set
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y]?.[x]; // Optional chaining for safety
                 if (cell && cell.element) {
                     cell.element.classList.remove('pressed'); // Ensure no stuck pressed state
                     if (cell.isMine) {
                         // Only reveal mines that are NOT correctly flagged
                         if (!cell.isFlagged) {
                             cell.element.classList.add('mine-revealed');
                             cell.element.textContent = "ðŸ’£";
                             // Highlight the one they clicked specifically
                             if (x === clickedX && y === clickedY) {
                                 cell.element.classList.add('mine'); // Use the specific 'hit' style
                             }
                         }
                     } else if (cell.isFlagged) { // Incorrectly flagged non-mine
                         cell.element.classList.remove('flagged');
                         cell.element.classList.add('incorrect-flag');
                         cell.element.textContent = 'X';
                     }
                 }
            }
        }
    }

   function checkWin() {
      if (gameOver) return;

      let revealedCount = 0;
      let mineCount = 0; // Recalculate actual mines
      let correctlyFlaggedCount = 0;

      for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
              const cell = grid[y]?.[x];
              if (!cell) continue; // Skip if cell data doesn't exist

              if (cell.isMine) {
                  mineCount++;
                  if (cell.isFlagged) {
                      correctlyFlaggedCount++;
                  }
              }
              if (cell.isRevealed) {
                  revealedCount++;
              }
          }
      }

      // Check if calculated mine count matches expected (sanity check)
      if (mineCount !== numMines && !firstClick) { // Allow mismatch before first click places mines
          console.warn(`Mine count mismatch! Expected ${numMines}, found ${mineCount}.`);
           // This might indicate an issue with mine placement or game state.
           // Should we proceed? Let's assume numMines is the source of truth for winning.
          mineCount = numMines; // Use the expected number for win check
      }


      // Win Condition 1: All non-mine squares revealed
      const totalSquares = width * height;
      const nonMineSquares = totalSquares - mineCount;
      if (revealedCount === nonMineSquares) {
          winGame(true); // Auto-flag remaining mines and win
          return;
      }

      // Win Condition 2: All mines correctly flagged AND all non-mines revealed
      // (This is implicitly covered by condition 1 if flagging is accurate, but good secondary check)
      // if (correctlyFlaggedCount === mineCount && minesLeft === 0 && revealedCount === nonMineSquares) {
      //     winGame();
      //     return;
      // }
    }


    function winGame(autoFlag = false) {
        if (gameOver) return; // Prevent multiple win triggers

        gameOver = true;
        stopTimer();
        console.log("Win condition met!");

        // Auto-flag remaining mines if necessary
        if (autoFlag) {
            let flagsPlaced = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (cell && cell.isMine && !cell.isFlagged && !cell.isRevealed) { // Only flag unrevealed mines
                        cell.isFlagged = true;
                        cell.element.classList.add('flagged');
                        cell.element.textContent = 'ðŸš©';
                        flagsPlaced++;
                    }
                }
            }
             // Adjust minesLeft counter based on auto-flagging
             minesLeft -= flagsPlaced;
             if (minesLeft < 0) minesLeft = 0; // Ensure counter doesn't go negative
             updateMinesLeftDisplay();
        }

        flagIncorrectlyPlaced(); // Show X on any flags placed on non-mines
        updateLeaderboard();
        showMessage("You Win! Time: " + time + " seconds");

        // Clean up interaction states
        if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
        isLeftMouseDown = false;
    }


    function flagIncorrectlyPlaced(){
        // Mark flags placed on non-mines with an 'X'
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y]?.[x];
                 if (cell && cell.isFlagged && !cell.isMine) {
                    cell.element.classList.remove('flagged');
                    cell.element.classList.add('incorrect-flag');
                    cell.element.textContent = 'X';
                 }
            }
        }
    }

    function startTimer() {
        if (!gameStarted) {
            gameStarted = true;
            time = 0; // Reset timer on start
            updateTimerDisplay();
            clearInterval(timerInterval); // Clear any existing interval
            timerInterval = setInterval(() => {
                if (!gameOver) { // Only increment if game is running
                    time++;
                    updateTimerDisplay();
                } else {
                    stopTimer(); // Stop if game over flag is set elsewhere
                }
            }, 1000);
        }
    }

    function stopTimer() {
       clearInterval(timerInterval);
       // Don't set gameStarted = false here, as game might be paused/won/lost
       // It should be reset only in restartGame()
    }

    // --- Refined Long Press Listener for Touch ---
   function addLongPressListener(element, callback) {
       let elementTouchTimerId = null; // Timer ID specific to this element's touch
       longPressFlaggedThisTouch = false; // Reset this flag for the element
       let startX, startY; // Store start coordinates for move detection

       const handleTouchStart = (e) => {
           // Only trigger for single touch, and if no timer is already running for this element
           if (e.touches.length === 1 && elementTouchTimerId === null) {
               longPressFlaggedThisTouch = false; // Reset on new touch start
               ignoreNextClick = false;          // Reset ignore flag too
               startX = e.touches[0].clientX;
               startY = e.touches[0].clientY;

               // Start the timer
               elementTouchTimerId = setTimeout(() => {
                   // Timer completed - this is a long press
                   longPressFlaggedThisTouch = true; // Set flag: timer completed
                   callback(e);                      // Execute the flag callback
                   ignoreNextClick = true;           // Set flag to ignore upcoming click/mouseup
                   elementTouchTimerId = null;       // Timer is done

                   // Prevent context menu on mobile after long press flag
                   // e.preventDefault(); // This might interfere with scrolling sometimes, let's see

                   // --- Visual Feedback Removal ---
                   // Remove 'pressed' state after action is done
                   const targetCell = e.target.closest('.cell');
                   if (targetCell) {
                       targetCell.classList.remove('pressed');
                   }


               }, longPressDelay);

                // --- Visual Feedback ---
                 const targetCell = e.target.closest('.cell');
                 if (targetCell && !targetCell.classList.contains('revealed')) { // Add pressed unless revealed
                      // Don't add pressed to flagged cells visually if it interferes
                       if (!targetCell.classList.contains('flagged')) {
                            targetCell.classList.add('pressed');
                       }
                 }
           }
       };

       const handleTouchEnd = (e) => {
            // --- Visual Feedback Removal ---
             const targetCell = e.target.closest('.cell');
             if (targetCell) {
                  targetCell.classList.remove('pressed');
             }


           if (elementTouchTimerId !== null) {
               // Timer was cleared *before* it completed (short tap)
               clearTimeout(elementTouchTimerId);
               elementTouchTimerId = null;
               // IMPORTANT: Do NOT set ignoreNextClick here. Let the subsequent handleClick decide.
               // If it was a short tap, handleClick should proceed.
           }
           // If elementTouchTimerId IS null here, it means either:
           // 1. The timer completed (long press). longPressFlaggedThisTouch will be true.
           // 2. The timer was cancelled by touchmove. longPressFlaggedThisTouch will be false.

           if (longPressFlaggedThisTouch) {
                // Long press DID complete. We've already set ignoreNextClick=true in the timer.
                // Reset the flag for the *next* interaction.
                longPressFlaggedThisTouch = false;
                // Prevent potential default actions like link navigation if the cell was an anchor (it isn't)
                // or context menu appearance on some browsers after touch end.
                e.preventDefault();
           }
           // Otherwise (short tap or move-cancelled tap), let the click event proceed normally.
       };

       const handleTouchMove = (e) => {
           if (elementTouchTimerId !== null) {
                 // Check if movement exceeds a threshold to cancel the long press
                 const currentX = e.touches[0].clientX;
                 const currentY = e.touches[0].clientY;
                 const deltaX = Math.abs(currentX - startX);
                 const deltaY = Math.abs(currentY - startY);
                 const moveThreshold = 10; // Pixels threshold

                 if (deltaX > moveThreshold || deltaY > moveThreshold) {
                     clearTimeout(elementTouchTimerId);
                     elementTouchTimerId = null;
                     longPressFlaggedThisTouch = false; // Move cancels long press
                     ignoreNextClick = false;         // Don't ignore click if moved

                     // --- Visual Feedback Removal ---
                      const targetCell = e.target.closest('.cell');
                      if (targetCell) {
                           targetCell.classList.remove('pressed');
                      }
                 }
           }
       };

        // Add Touch Listeners: passive: false recommended for touchstart/touchend if preventDefault is used
        element.addEventListener('touchstart', handleTouchStart, { passive: false });
        element.addEventListener('touchend', handleTouchEnd, { passive: false });
        element.addEventListener('touchmove', handleTouchMove, { passive: false }); // Check if move needs preventDefault

       // Store handlers for removal
       element._touchStartHandler = handleTouchStart;
       element._touchEndHandler = handleTouchEnd;
       element._touchMoveHandler = handleTouchMove;

       // Mouse long press is handled separately in handleCellMouseDown
       // Add mouseleave cleanup for mouse long press timer started in mousedown
        const handleMouseLeave = () => {
             clearTimeout(mouseLongPressTimerId); // Clear potential MOUSE timer
             mouseLongPressTimerId = null;
             longPressJustFinishedMouse = false; // Reset mouse flag
             if (isLeftMouseDown && pressedCellElement === element) { // If leaving the pressed cell
                element.classList.remove('pressed');
                // Keep pressedCellElement assigned until mouseup or mouseover elsewhere
                 pressedCellElement = null; // Make sure other cells can be pressed
             }
        };
        element.addEventListener('mouseleave', handleMouseLeave);
        element._mouseLeaveHandlerLP = handleMouseLeave; // Store for removal
   }

   function removeLongPressListener(element) {
        // Remove touch listeners using the stored handlers
        if (element._touchStartHandler) {
            element.removeEventListener('touchstart', element._touchStartHandler, { passive: false });
            delete element._touchStartHandler;
        }
        if (element._touchEndHandler) {
            element.removeEventListener('touchend', element._touchEndHandler, { passive: false });
            delete element._touchEndHandler;
        }
        if (element._touchMoveHandler) {
            element.removeEventListener('touchmove', element._touchMoveHandler, { passive: false });
            delete element._touchMoveHandler;
        }
         // Remove mouse leave listener added by addLongPressListener
         if (element._mouseLeaveHandlerLP) {
             element.removeEventListener('mouseleave', element._mouseLeaveHandlerLP);
             delete element._mouseLeaveHandlerLP;
         }
    }
    // --- END Refined Long Press ---


    function toggleSettings() {
        const settingsPanel = document.getElementById('settings-panel');
        const overlay = document.getElementById('overlay');
        const attemptsSpan = document.getElementById('generation-attempts');
        if(settingsPanel.style.display === "block") {
            settingsPanel.style.display = "none";
            overlay.style.display = 'none';
            // Show attempts only if No Guess Mode is active and game hasn't started
             if (noGuessMode && firstClick && generationAttempts > 0) {
                 attemptsSpan.textContent = `(${generationAttempts} attempts)`;
             } else {
                 attemptsSpan.textContent = ''; // Clear otherwise
             }

        }
        else {
            settingsPanel.style.display = "block";
            overlay.style.display = 'block';
            document.getElementById('long-press-delay-value').textContent = longPressDelay;
            if (currentDifficulty === 'custom') {
               document.querySelector('.custom-settings').classList.add('active');
               // Update max mines for custom based on current dimensions
                const maxMines = (parseInt(document.getElementById('width').value) * parseInt(document.getElementById('height').value)) - 9;
                document.getElementById('mines').max = maxMines > 0 ? maxMines : 1;
            } else {
               document.querySelector('.custom-settings').classList.remove('active');
            }
             // Hide generation attempts text when opening settings
             attemptsSpan.textContent = '';
        }
    }
    function updateTimerDisplay(){
        if (document.querySelector('#timer > div:nth-child(2)')) {
            document.querySelector('#timer > div:nth-child(2)').textContent = time;
        }
    }
    function updateMinesLeftDisplay(){
         const displayElement = document.querySelector('#mines-left > div:nth-child(2)');
         if (displayElement) {
            displayElement.textContent = minesLeft < 0 ? 0 : minesLeft; // Prevent negative display
         }
    }

    function setDifficulty(difficulty) {
      currentDifficulty = difficulty;
      const customSettings = document.querySelector('.custom-settings');
      const minesInput = document.getElementById('mines');
       document.getElementById('generation-attempts').textContent = ''; // Clear attempts display

      switch (difficulty) {
        case 'beginner': width = 9; height = 9; numMines = 10; customSettings.classList.remove('active'); break;
        case 'intermediate': width = 16; height = 16; numMines = 40; customSettings.classList.remove('active'); break;
        case 'expert': width = 30; height = 16; numMines = 99; customSettings.classList.remove('active'); break;
        case 'custom':
          customSettings.classList.add('active');
            // Don't change w/h/n here, wait for apply or load from storage
            // Ensure current values are displayed
            document.getElementById('width').value = width;
            document.getElementById('height').value = height;
            minesInput.value = numMines;
             // Update max mines for custom based on current dimensions
             const maxMinesCustom = (width * height) - 9;
             minesInput.max = maxMinesCustom > 0 ? maxMinesCustom : 1;
            return; // Don't restart yet for custom, wait for Apply
      }
        // Update display for non-custom difficulties
        document.getElementById('width').value = width;
        document.getElementById('height').value = height;
        minesInput.value = numMines;
        // Update max mines for standard difficulties (redundant but safe)
        const maxMinesStandard = (width * height) - 9;
        minesInput.max = maxMinesStandard > 0 ? maxMinesStandard : 1;


        // Save the new standard difficulty immediately
        localStorage.setItem('currentDifficulty', currentDifficulty);
        localStorage.setItem('width', width);
        localStorage.setItem('height', height);
        localStorage.setItem('numMines', numMines);

        minesLeft = numMines;
        restartGame();
    }

   function applySettings() {
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        const minesInput = document.getElementById('mines');

        if (currentDifficulty === 'custom') {
            const newWidth = parseInt(widthInput.value);
            const newHeight = parseInt(heightInput.value);
            const newNumMines = parseInt(minesInput.value);

             if (isNaN(newWidth) || newWidth < 5 || newWidth > 50) { alert('Width must be between 5 and 50.'); return; }
             if (isNaN(newHeight) || newHeight < 5 || newHeight > 50) { alert('Height must be between 5 and 50.'); return; }

             // Ensure max mines attribute is up-to-date before checking value
             const maxMines = (newWidth * newHeight) - 9; // Need 9 safe squares
             minesInput.max = maxMines > 0 ? maxMines : 1; // Update the input's max attribute

             if (isNaN(newNumMines) || newNumMines < 1 || newNumMines > maxMines) {
                 alert(`Mines must be between 1 and ${maxMines} (to allow safe start).`);
                 return;
              }
             width = newWidth;
             height = newHeight;
             numMines = newNumMines;
        } else {
             // If not custom, ensure W/H/N match the selected standard difficulty
              switch (currentDifficulty) {
                  case 'beginner': width = 9; height = 9; numMines = 10; break;
                  case 'intermediate': width = 16; height = 16; numMines = 40; break;
                  case 'expert': width = 30; height = 16; numMines = 99; break;
              }
               // Update input displays to match standard difficulty
               widthInput.value = width;
               heightInput.value = height;
               minesInput.value = numMines;
               const maxMinesStd = (width * height) - 9;
               minesInput.max = maxMinesStd > 0 ? maxMinesStd : 1;
        }


        // --- Save common settings ---
        playerName = document.getElementById('player-name').value.trim() || "Player";
        localStorage.setItem('playerName', playerName);
        document.getElementById('player-name').value = playerName; // Update input field

        const lightModeCheckbox = document.getElementById('light-mode');
        flagMethod = document.getElementById('flag-method').value;
        longPressDelay = parseInt(document.getElementById('long-press-delay').value);
        chordMethod = document.getElementById('chord-method').value;
        noGuessMode = document.getElementById('no-guess-mode').checked; // Save No Guess Mode state

        localStorage.setItem('darkMode', lightModeCheckbox.checked ? 'enabled' : 'disabled');
        localStorage.setItem('flagMethod', flagMethod);
        localStorage.setItem('longPressDelay', longPressDelay);
        localStorage.setItem('chordMethod', chordMethod);
        localStorage.setItem('noGuessMode', noGuessMode); // Save No Guess Mode state

        // Always save current difficulty and dimensions (even if standard, in case user switched from custom)
        localStorage.setItem('currentDifficulty', currentDifficulty);
        localStorage.setItem('width', width);
        localStorage.setItem('height', height);
        localStorage.setItem('numMines', numMines);

        // --- Apply visual settings ---
        if (lightModeCheckbox.checked) {
            document.body.classList.add('light-mode');
            document.getElementById('settings-panel').style.backgroundColor = "white";
            document.getElementById('message-box').style.backgroundColor = "white";
        } else {
            document.body.classList.remove('light-mode');
            document.getElementById('settings-panel').style.backgroundColor = "var(--container-bg)";
            document.getElementById('message-box').style.backgroundColor = "var(--container-bg)";
        }

        // --- Restart and close ---
        minesLeft = numMines;
        restartGame(); // Restart to apply potentially new dimensions/mine count
        toggleSettings(); // Close settings panel
    }

    function showMessage(message) {
        document.getElementById('message-text').textContent = message;
        document.getElementById('message-box').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
    }

    function restartGame() {
        stopTimer();
        time = 0;
        updateTimerDisplay();
        gameStarted = false;
        firstClick = true;
        gameOver = false;
        minesLeft = numMines
        updateMinesLeftDisplay();
        generationAttempts = 0; // Reset attempts counter
        const attemptsSpan = document.getElementById('generation-attempts');
        if(attemptsSpan) attemptsSpan.textContent = ''; // Clear attempts display on restart


        // Reset ALL interaction states thoroughly
        ignoreNextClick = false;
        longPressFlaggedThisTouch = false; // Reset touch flag
        longPressJustFinishedMouse = false; // Reset mouse flag
        isLeftMouseDown = false;
         if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
         initialMouseDownCell = null;
        clearTimeout(touchLongPressTimerId); touchLongPressTimerId = null; // Clear touch timer
        clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null; // Clear mouse timer
        clearTimeout(doubleTapFlagTimer); doubleTapFlagTimer = null;
        clearTimeout(doubleTapChordTimer); doubleTapChordTimer = null;

        // Remove the global mouseup listener before creating the grid again
        document.removeEventListener('mouseup', handleDocumentMouseUp);

        createGrid(); // Recreate grid and reattach listeners
        document.getElementById('message-box').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';

         // Re-apply correct flagging listeners based on current settings
         updateFlagMethod();
    }

    document.getElementById('long-press-delay').addEventListener('input', (event) => {
        document.getElementById('long-press-delay-value').textContent = event.target.value;
        // Update delay immediately ONLY if you want it live without apply (usually not recommended)
        // longPressDelay = parseInt(event.target.value);
        // updateFlagMethod(); // Re-attach listeners with new delay? Complicated. Better to wait for Apply.
    });

      function updateLeaderboard() {
        // Only submit scores for standard difficulties
        if (currentDifficulty === 'beginner' || currentDifficulty === 'intermediate' || currentDifficulty === 'expert') {
            const currentName = document.getElementById('player-name').value.trim();
             // Do not submit if name is empty or default "Player"
             if (!currentName || currentName.toLowerCase() === "player") {
                 console.log("Score not submitted: Enter a valid player name in Settings.");
                 // Update local leaderboard anyway
                 let bestTime = localStorage.getItem(`leaderboard-${currentDifficulty}`);
                 if (bestTime === null || time < parseInt(bestTime)) {
                     localStorage.setItem(`leaderboard-${currentDifficulty}`, time);
                     bestTime = time;
                 }
                 const tdElement = document.getElementById(`leaderboard-${currentDifficulty}-local`);
                 if (tdElement) {
                     tdElement.textContent = bestTime === null ? '-' : bestTime + 's';
                 }
                 return;
             }

            // Submit to Online Leaderboard
            const scoresCollection = db.collection('leaderboard');
            scoresCollection.add({
                playerName: currentName,
                difficulty: currentDifficulty,
                score: time,
                timestamp: firebase.firestore.FieldValue.serverTimestamp() // Use server time
            }).then(() => {
                console.log("Score submitted to online leaderboard!");
                loadOnlineLeaderboard(); // Refresh leaderboard display
            }).catch((error) => {
                console.error("Error submitting score: ", error);
                document.getElementById('leaderboard-error').textContent = 'Error submitting score.';
                document.getElementById('leaderboard-error').style.display = 'block';
            });

            // Update Local Leaderboard
            let bestTime = localStorage.getItem(`leaderboard-${currentDifficulty}`);
            if (bestTime === null || time < parseInt(bestTime)) {
                localStorage.setItem(`leaderboard-${currentDifficulty}`, time);
                bestTime = time;
            }
            const tdElement = document.getElementById(`leaderboard-${currentDifficulty}-local`);
             if (tdElement) { // Check if element exists
                 tdElement.textContent = bestTime === null ? '-' : bestTime + 's';
             }
        } else {
             console.log("Score not submitted for custom difficulty.");
        }
    }
async function fetchScoresRecursive(difficulty, targetCount, collectedScores = [], lastVisible = null) {
    // Define the base query
    let q = db.collection('leaderboard')
              .where('difficulty', '==', difficulty)
              .where('score', '>', 1) // Ensure score is positive (valid time) 
        //temperarily 1 instead of 0 because of many cheated 1 second scores
              .orderBy('score', 'asc'); // Order by score ascending

    // If we have a document to start after (for pagination)
    if (lastVisible) {
        q = q.startAfter(lastVisible);
    }

    // Fetch a batch. Fetching targetCount is usually sufficient here.
    q = q.limit(targetCount);

    try {
        const documentSnapshots = await q.get();

        // Get the last document for the next potential fetch
        const newLastVisible = documentSnapshots.docs[documentSnapshots.docs.length - 1];
        let addedCount = 0;

        documentSnapshots.forEach((doc) => {
            const data = doc.data();
            // Basic validation: ensure score is a number > 0 and we haven't reached the target yet
            if (typeof data.score === 'number' && data.score > 0 && collectedScores.length < targetCount) {
                 collectedScores.push(data);
                 addedCount++;
            }
        });

        // Check if more fetching is needed:
        // - We haven't reached the target count yet.
        // - We actually added scores in this batch (addedCount > 0 prevents infinite loops on empty results).
        // - Firestore indicated there might be more documents (newLastVisible is not null).
        // - The number of docs received equals the limit (suggests more might exist beyond the limit).
         if (collectedScores.length < targetCount && addedCount > 0 && newLastVisible && documentSnapshots.docs.length === targetCount) {
             const remainingCount = targetCount - collectedScores.length;
             return fetchScoresRecursive(difficulty, remainingCount, collectedScores, newLastVisible);
        } else {
             // We have enough scores OR there are no more documents to fetch
             return collectedScores; // Return the final list
        }
    } catch (error) {
        console.error(`Error fetching scores for ${difficulty}:`, error);
        document.getElementById('leaderboard-error').textContent = `Error loading ${difficulty} scores.`;
        document.getElementById('leaderboard-error').style.display = 'block';
        // Return what we have collected so far, or an empty array on complete failure
        return collectedScores;
    }
}


async function loadOnlineLeaderboard() {
    document.getElementById('leaderboard-loading').style.display = 'block';
    document.getElementById('leaderboard-error').style.display = 'none'; // Hide previous errors
    // Clear old data immediately
    document.getElementById('leaderboard-beginner').innerHTML = '';
    document.getElementById('leaderboard-intermediate').innerHTML = '';
    document.getElementById('leaderboard-expert').innerHTML = '';

    const difficulties = ['beginner', 'intermediate', 'expert'];
    const targetScoreCount = 10; // We want the top 10 scores per difficulty

    try {
        const promises = difficulties.map(async (difficulty) => {
            const leaderboardBody = document.getElementById(`leaderboard-${difficulty}`);
            if (!leaderboardBody) {
                console.error("Leaderboard body not found for:", difficulty);
                return; // Skip this difficulty if element doesn't exist
            }
            leaderboardBody.innerHTML = '<tr><td colspan="3">Loading...</td></tr>'; // Show loading state per table

            // Fetch the required scores recursively
            const scores = await fetchScoresRecursive(difficulty, targetScoreCount, []);

             leaderboardBody.innerHTML = ''; // Clear loading message

            // Populate the table with the fetched scores
            if (scores.length > 0) {
                let rank = 1;
                // Ensure scores are sorted by score client-side as a fallback
                 scores.sort((a, b) => a.score - b.score);
                scores.forEach((data) => {
                    const row = leaderboardBody.insertRow();
                    row.insertCell().textContent = rank++;
                    // Sanitize player name slightly
                    const nameCell = row.insertCell();
                    nameCell.textContent = String(data.playerName || 'Anonymous').substring(0, 20); // Limit length, handle null
                    row.insertCell().textContent = data.score + 's';
                });
            } else {
                 leaderboardBody.innerHTML = '<tr><td colspan="3">No scores yet.</td></tr>';
            }
        });

        // Wait for all fetching and rendering operations to complete
        await Promise.all(promises);

        // Hide global loading indicator only after all promises resolve successfully
        document.getElementById('leaderboard-loading').style.display = 'none';

    } catch (error) {
        // Catch errors from Promise.all itself or leaderboardBody lookup.
        // Specific fetch errors are handled within fetchScoresRecursive.
        console.error("Error loading one or more online leaderboards:", error);
        document.getElementById('leaderboard-loading').style.display = 'none';
        // Display a general error if no specific error was already shown
        if (document.getElementById('leaderboard-error').style.display === 'none') {
             document.getElementById('leaderboard-error').textContent = 'Error loading online leaderboards. Please try again later.';
             document.getElementById('leaderboard-error').style.display = 'block';
        }
    }
}

    function loadLeaderboard() {
        const difficulties = ['beginner', 'intermediate', 'expert'];
        difficulties.forEach(difficulty => {
            const bestTime = localStorage.getItem(`leaderboard-${difficulty}`);
            const tdElement = document.getElementById(`leaderboard-${difficulty}-local`); // Get TD element
             if (tdElement) { // Check if element exists
                 tdElement.textContent = bestTime === null ? '-' : bestTime + 's';
             }
        });
    }

    function loadSettings() {
      playerName = localStorage.getItem('playerName') || 'Player';
      document.getElementById('player-name').value = playerName;

      const savedDarkMode = localStorage.getItem('darkMode');
      const lightModeCheckbox = document.getElementById('light-mode');
      if (savedDarkMode === 'enabled') {
          document.body.classList.add('light-mode');
          lightModeCheckbox.checked = true;
          document.getElementById('settings-panel').style.backgroundColor = "white";
          document.getElementById('message-box').style.backgroundColor = "white";
      } else {
           document.body.classList.remove('light-mode');
           lightModeCheckbox.checked = false;
            document.getElementById('settings-panel').style.backgroundColor = "var(--container-bg)";
            document.getElementById('message-box').style.backgroundColor = "var(--container-bg)";
      }

      flagMethod = localStorage.getItem('flagMethod') || 'longPress';
      document.getElementById('flag-method').value = flagMethod;
      longPressDelay = parseInt(localStorage.getItem('longPressDelay')) || 500;
      document.getElementById('long-press-delay').value = longPressDelay;
      document.getElementById('long-press-delay-value').textContent = longPressDelay;

      chordMethod = localStorage.getItem('chordMethod') || 'singleTap';
      document.getElementById('chord-method').value = chordMethod;

      noGuessMode = localStorage.getItem('noGuessMode') === 'true'; // Load No Guess Mode state
      document.getElementById('no-guess-mode').checked = noGuessMode;
      document.getElementById('generation-attempts').textContent = ''; // Clear attempts display on load


      currentDifficulty = localStorage.getItem('currentDifficulty') || 'beginner';
      width = parseInt(localStorage.getItem('width')) || 9;
      height = parseInt(localStorage.getItem('height')) || 9;
      numMines = parseInt(localStorage.getItem('numMines')) || 10;

      // Apply loaded settings
      const minesInput = document.getElementById('mines');
      if (currentDifficulty === 'custom') {
           document.getElementById('width').value = width;
           document.getElementById('height').value = height;
           minesInput.value = numMines;
           const maxMines = (width * height) - 9;
           minesInput.max = maxMines > 0 ? maxMines : 1;
           document.querySelector('.custom-settings').classList.add('active');
           // Need to restart manually for custom settings loaded
           minesLeft = numMines;
           restartGame();
      } else {
          document.querySelector('.custom-settings').classList.remove('active');
           // setDifficulty will update inputs, potentially change W/H/N, and restart
           setDifficulty(currentDifficulty);
      }

      // Ensure flag listeners match loaded settings *after* potential restart
      updateFlagMethod();

    }

    // --- No Guess Mode Solver Logic ---

    function getNeighbors(x, y, W, H) {
        const neighbors = [];
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const newX = x + dx;
                const newY = y + dy;
                if (newX >= 0 && newX < W && newY >= 0 && newY < H) {
                    neighbors.push({ x: newX, y: newY });
                }
            }
        }
        return neighbors;
    }

     function isSolvableWithoutGuessing(startX, startY) {
         // Create a temporary grid representing the solver's knowledge state
         // state: -2 = unknown, -1 = flagged, 0-8 = revealed number
         const solverGrid = Array(height).fill(null).map(() => Array(width).fill(null).map(() => ({ state: -2 })));
         let revealedCount = 0;
         let minesFound = 0;
         const totalNonMines = (width * height) - numMines;
         const processQueue = []; // Queue for zero propagation

         // --- Solver Helper Functions ---
         const solverReveal = (x, y) => {
             if (x < 0 || x >= width || y < 0 || y >= height || solverGrid[y][x].state !== -2) return false;
             if (grid[y][x].isMine) return false; // Should not happen if logic is sound

             const adjacentMines = grid[y][x].adjacentMines;
             solverGrid[y][x].state = adjacentMines;
             revealedCount++;

             if (adjacentMines === 0) {
                 getNeighbors(x, y, width, height).forEach(n => {
                     if (solverGrid[n.y][n.x].state === -2) {
                         processQueue.push(n); // Add unknown neighbors of zero to queue
                     }
                 });
             }
             return true;
         };

         const solverFlag = (x, y) => {
             if (x < 0 || x >= width || y < 0 || y >= height || solverGrid[y][x].state !== -2) return false;
             if (!grid[y][x].isMine) return false; // Should not happen

             solverGrid[y][x].state = -1;
             minesFound++;
             return true;
         };

         // --- Solver Execution ---

         // 1. Initial Reveal (Guaranteed Safe Area)
         for (let dy = -1; dy <= 1; dy++) {
             for (let dx = -1; dx <= 1; dx++) {
                 solverReveal(startX + dx, startY + dy); // Ignore return value here, it's guaranteed safe
             }
         }

         // 2. Main Deduction Loop
         let madeProgress = true;
         while (madeProgress) {
             madeProgress = false;

             // Process zero propagation first
             while (processQueue.length > 0) {
                 const { x, y } = processQueue.shift();
                 if (solverGrid[y][x].state === -2) { // Re-check state in case it was processed differently
                     if (solverReveal(x, y)) {
                         madeProgress = true;
                     }
                 }
             }

             // Apply deduction rules (iterate multiple times if needed, or until no progress)
             let innerProgress = true;
             while(innerProgress){
                 innerProgress = false;
                 for (let y = 0; y < height; y++) {
                     for (let x = 0; x < width; x++) {
                         const cellState = solverGrid[y][x].state;
                         if (cellState >= 1 && cellState <= 8) {
                             const neighbors = getNeighbors(x, y, width, height);
                             let unknownNeighbors = [];
                             let flaggedNeighbors = 0;
                             neighbors.forEach(n => {
                                 const nState = solverGrid[n.y][n.x].state;
                                 if (nState === -2) unknownNeighbors.push(n);
                                 else if (nState === -1) flaggedNeighbors++;
                             });

                             // Rule 1: If known_flags == number, reveal rest
                             if (flaggedNeighbors === cellState && unknownNeighbors.length > 0) {
                                 unknownNeighbors.forEach(n => {
                                     if (solverReveal(n.x, n.y)) {
                                         innerProgress = true; madeProgress = true;
                                     }
                                 });
                                  // After revealing, this rule is done for this cell in this pass
                                 continue;
                             }

                             // Rule 2: If unknown_neighbors + known_flags == number, flag rest
                             if (unknownNeighbors.length > 0 && flaggedNeighbors + unknownNeighbors.length === cellState) {
                                 unknownNeighbors.forEach(n => {
                                     if (solverFlag(n.x, n.y)) {
                                          innerProgress = true; madeProgress = true;
                                     } else {
                                         // If solver tries to flag a non-mine, grid is unsolvable
                                         // console.error("NG Solver: Rule 2 failed - tried to flag non-mine at", n.x, n.y);
                                         // This indicates an issue with the grid generation or solver logic itself.
                                         return false; // Unsolvable
                                     }
                                 });
                                  // After flagging, this rule is done for this cell in this pass
                                 continue;
                             }
                         }
                     }
                 }
                 // Process queue again after rule application, as reveals might create new zeros
                 while (processQueue.length > 0) {
                     const { x, y } = processQueue.shift();
                     if (solverGrid[y][x].state === -2) {
                         if (solverReveal(x, y)) {
                              innerProgress = true; madeProgress = true; // Progress was made
                         }
                     }
                 }

             } // End inner while loop

         } // End outer while(madeProgress)

         // 3. Final Check: Solvable if all non-mines are revealed
         return revealedCount === totalNonMines;
     }


    // --- Initialize ---
    loadSettings(); // Loads settings and potentially calls restartGame
    loadLeaderboard();
    loadOnlineLeaderboard();
    // createGrid() is called by loadSettings -> setDifficulty -> restartGame OR directly by loadSettings if custom

    </script>
</body>
</html>
